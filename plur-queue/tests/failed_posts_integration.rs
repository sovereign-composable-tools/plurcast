//! Integration tests for plur-queue failed post management commands
//!
//! Tests the 'plur-queue failed' commands: list, clear, and delete

use assert_cmd::Command;
use libplurcast::{Database, Post, PostStatus};
use predicates::prelude::*;
use std::fs;
use tempfile::TempDir;

/// Setup test environment with config and database
async fn setup_test_env() -> (TempDir, String, String) {
    let temp_dir = TempDir::new().unwrap();
    let config_path = temp_dir.path().join("config.toml");
    let db_path = temp_dir.path().join("test.db");

    // Create minimal config
    let config_content = format!(
        r#"
[database]
path = "{}"

[defaults]
platforms = ["nostr"]
"#,
        db_path.display().to_string().replace('\\', "/")
    );

    fs::write(&config_path, config_content).unwrap();

    // Initialize database
    let _db = Database::new(db_path.to_str().unwrap()).await.unwrap();

    (
        temp_dir,
        config_path.to_str().unwrap().to_string(),
        db_path.to_str().unwrap().to_string(),
    )
}

/// Create a failed post with post_records containing error information
async fn create_failed_post(db_path: &str, content: &str) -> String {
    use libplurcast::PostRecord;

    let db = Database::new(db_path).await.unwrap();
    let now = chrono::Utc::now().timestamp();

    let post = Post {
        id: uuid::Uuid::new_v4().to_string(),
        content: content.to_string(),
        created_at: now,
        scheduled_at: None,
        status: PostStatus::Failed,
        metadata: Some(r#"{"platforms":["nostr"]}"#.to_string()),
    };

    let post_id = post.id.clone();
    db.create_post(&post).await.unwrap();

    // Create a post_record showing a failed attempt with error message
    let record = PostRecord {
        id: None, // Will be auto-generated by database
        post_id: post_id.clone(),
        platform: "nostr".to_string(),
        platform_post_id: None,
        posted_at: Some(now),
        success: false,
        error_message: Some("rate-limited".to_string()),
        account_name: "default".to_string(),
    };

    db.create_post_record(&record).await.unwrap();
    post_id
}

/// Create a scheduled post (not failed)
async fn create_scheduled_post(db_path: &str, content: &str) -> String {
    let db = Database::new(db_path).await.unwrap();
    let now = chrono::Utc::now().timestamp();

    let post = Post {
        id: uuid::Uuid::new_v4().to_string(),
        content: content.to_string(),
        created_at: now,
        scheduled_at: Some(now + 3600), // 1 hour from now
        status: PostStatus::Scheduled,
        metadata: Some(r#"{"platforms":["nostr"]}"#.to_string()),
    };

    let post_id = post.id.clone();
    db.create_post(&post).await.unwrap();
    post_id
}

// FAILED LIST TESTS

#[tokio::test]
async fn test_failed_list_empty() {
    let (_temp_dir, config_path, _db_path) = setup_test_env().await;

    let mut cmd = Command::cargo_bin("plur-queue").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("list")
        .assert()
        .success()
        .stdout(predicate::str::contains("No failed posts"));
}

#[tokio::test]
async fn test_failed_list_shows_failed_posts() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    // Create 3 failed posts
    create_failed_post(&db_path, "Failed post 1").await;
    create_failed_post(&db_path, "Failed post 2").await;
    create_failed_post(&db_path, "Failed post 3").await;

    let mut cmd = Command::cargo_bin("plur-queue").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("list")
        .assert()
        .success()
        .stdout(predicate::str::contains("Failed post 1"))
        .stdout(predicate::str::contains("Failed post 2"))
        .stdout(predicate::str::contains("Failed post 3"));
}

#[tokio::test]
async fn test_failed_list_only_shows_failed_not_scheduled() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    // Create both failed and scheduled posts
    create_failed_post(&db_path, "Failed post").await;
    create_scheduled_post(&db_path, "Scheduled post").await;

    let mut cmd = Command::cargo_bin("plur-queue").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("list")
        .assert()
        .success()
        .stdout(predicate::str::contains("Failed post"))
        .stdout(predicate::str::contains("Scheduled post").not());
}

#[tokio::test]
async fn test_failed_list_shows_post_ids() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    create_failed_post(&db_path, "Failed post").await;

    let mut cmd = Command::cargo_bin("plur-queue").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("list")
        .assert()
        .success()
        // Should show UUID format
        .stdout(predicate::str::is_match(r"[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}").unwrap());
}

#[tokio::test]
async fn test_failed_list_shows_error_info() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    create_failed_post(&db_path, "Failed post").await;

    let mut cmd = Command::cargo_bin("plur-queue").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("list")
        .assert()
        .success()
        .stdout(predicate::str::contains("rate-limited"));
}

// FAILED LIST JSON FORMAT TESTS

#[tokio::test]
async fn test_failed_list_json_format() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    create_failed_post(&db_path, "Failed post 1").await;
    create_failed_post(&db_path, "Failed post 2").await;

    let mut cmd = Command::cargo_bin("plur-queue").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("list")
        .arg("--format")
        .arg("json")
        .assert()
        .success()
        .stdout(predicate::str::starts_with("["))
        .stdout(predicate::str::ends_with("]\n"))
        .stdout(predicate::str::contains("\"id\""))
        .stdout(predicate::str::contains("\"content\""))
        .stdout(predicate::str::contains("\"status\""))
        .stdout(predicate::str::contains("\"failed\""));
}

#[tokio::test]
async fn test_failed_list_json_format_empty() {
    let (_temp_dir, config_path, _db_path) = setup_test_env().await;

    let mut cmd = Command::cargo_bin("plur-queue").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("list")
        .arg("--format")
        .arg("json")
        .assert()
        .success()
        .stdout(predicate::str::contains("[]"));
}

// FAILED CLEAR TESTS

#[tokio::test]
async fn test_failed_clear_empty() {
    let (_temp_dir, config_path, _db_path) = setup_test_env().await;

    let mut cmd = Command::cargo_bin("plur-queue").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("clear")
        .arg("--force")
        .assert()
        .success()
        .stdout(predicate::str::contains("No failed posts to clear"));
}

#[tokio::test]
async fn test_failed_clear_with_force() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    // Create 3 failed posts
    create_failed_post(&db_path, "Failed post 1").await;
    create_failed_post(&db_path, "Failed post 2").await;
    create_failed_post(&db_path, "Failed post 3").await;

    let mut cmd = Command::cargo_bin("plur-queue").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("clear")
        .arg("--force")
        .assert()
        .success()
        .stdout(predicate::str::contains("Cleared 3 failed post(s)"));

    // Verify posts are gone
    let db = Database::new(&db_path).await.unwrap();
    let failed_posts = db.get_failed_posts().await.unwrap();
    assert_eq!(failed_posts.len(), 0, "All failed posts should be deleted");
}

#[tokio::test]
async fn test_failed_clear_only_deletes_failed_not_scheduled() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    // Create both failed and scheduled posts
    create_failed_post(&db_path, "Failed post").await;
    let scheduled_id = create_scheduled_post(&db_path, "Scheduled post").await;

    let mut cmd = Command::cargo_bin("plur-queue").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("clear")
        .arg("--force")
        .assert()
        .success()
        .stdout(predicate::str::contains("Cleared 1 failed post(s)"));

    // Verify scheduled post is still there
    let db = Database::new(&db_path).await.unwrap();
    let scheduled_post = db.get_post(&scheduled_id).await.unwrap();
    assert!(scheduled_post.is_some(), "Scheduled post should not be deleted");
    assert_eq!(
        scheduled_post.unwrap().status,
        PostStatus::Scheduled,
        "Scheduled post should still be scheduled"
    );
}

#[tokio::test]
async fn test_failed_clear_without_force_requires_confirmation() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    create_failed_post(&db_path, "Failed post").await;

    let mut cmd = Command::cargo_bin("plur-queue").unwrap();

    // Without --force, should fail (can't provide stdin in integration test)
    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("clear")
        .assert()
        .failure()
        .code(3);
}

// FAILED DELETE TESTS

#[tokio::test]
async fn test_failed_delete_specific_post() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    let post_id = create_failed_post(&db_path, "Failed post to delete").await;
    let keep_id = create_failed_post(&db_path, "Failed post to keep").await;

    let mut cmd = Command::cargo_bin("plur-queue").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("delete")
        .arg(&post_id)
        .arg("--force")
        .assert()
        .success()
        .stdout(predicate::str::contains(&format!("Deleted failed post: {}", post_id)));

    // Verify only the specified post was deleted
    let db = Database::new(&db_path).await.unwrap();
    let deleted_post = db.get_post(&post_id).await.unwrap();
    let kept_post = db.get_post(&keep_id).await.unwrap();

    assert!(deleted_post.is_none(), "Specified post should be deleted");
    assert!(kept_post.is_some(), "Other failed post should remain");
}

#[tokio::test]
async fn test_failed_delete_nonexistent_post() {
    let (_temp_dir, config_path, _db_path) = setup_test_env().await;

    let fake_id = uuid::Uuid::new_v4().to_string();

    let mut cmd = Command::cargo_bin("plur-queue").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("delete")
        .arg(&fake_id)
        .arg("--force")
        .assert()
        .failure()
        .code(3)
        .stderr(predicate::str::contains("Post not found"));
}

#[tokio::test]
async fn test_failed_delete_scheduled_post_fails() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    // Try to delete a scheduled post (not failed)
    let scheduled_id = create_scheduled_post(&db_path, "Scheduled post").await;

    let mut cmd = Command::cargo_bin("plur-queue").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("delete")
        .arg(&scheduled_id)
        .arg("--force")
        .assert()
        .failure()
        .code(3)
        .stderr(predicate::str::contains("Post is not in failed status"));
}

#[tokio::test]
async fn test_failed_delete_without_force_requires_confirmation() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    let post_id = create_failed_post(&db_path, "Failed post").await;

    let mut cmd = Command::cargo_bin("plur-queue").unwrap();

    // Without --force, should fail (can't provide stdin in integration test)
    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("delete")
        .arg(&post_id)
        .assert()
        .failure()
        .code(3);
}

#[tokio::test]
async fn test_failed_delete_invalid_uuid_format() {
    let (_temp_dir, config_path, _db_path) = setup_test_env().await;

    let mut cmd = Command::cargo_bin("plur-queue").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("delete")
        .arg("not-a-valid-uuid")
        .arg("--force")
        .assert()
        .failure()
        .code(3);
}

// MULTIPLE FAILED POSTS TESTS

#[tokio::test]
async fn test_failed_list_with_many_posts() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    // Create 10 failed posts
    for i in 1..=10 {
        create_failed_post(&db_path, &format!("Failed post {}", i)).await;
    }

    let mut cmd = Command::cargo_bin("plur-queue").unwrap();

    let output = cmd
        .env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("list")
        .assert()
        .success()
        .get_output()
        .stdout
        .clone();

    let stdout = String::from_utf8(output).unwrap();

    // Should show all 10 posts
    for i in 1..=10 {
        assert!(
            stdout.contains(&format!("Failed post {}", i)),
            "Should show all failed posts"
        );
    }
}

#[tokio::test]
async fn test_failed_clear_with_many_posts() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    // Create 20 failed posts
    for i in 1..=20 {
        create_failed_post(&db_path, &format!("Failed post {}", i)).await;
    }

    let mut cmd = Command::cargo_bin("plur-queue").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("clear")
        .arg("--force")
        .assert()
        .success()
        .stdout(predicate::str::contains("Cleared 20 failed post(s)"));

    // Verify all are gone
    let db = Database::new(&db_path).await.unwrap();
    let failed_posts = db.get_failed_posts().await.unwrap();
    assert_eq!(failed_posts.len(), 0, "All failed posts should be deleted");
}

// WORKFLOW TESTS

#[tokio::test]
async fn test_workflow_list_then_clear() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    // Create failed posts
    create_failed_post(&db_path, "Failed post 1").await;
    create_failed_post(&db_path, "Failed post 2").await;

    // First, list them
    let mut cmd = Command::cargo_bin("plur-queue").unwrap();
    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("list")
        .assert()
        .success()
        .stdout(predicate::str::contains("Failed post 1"));

    // Then, clear them
    let mut cmd = Command::cargo_bin("plur-queue").unwrap();
    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("clear")
        .arg("--force")
        .assert()
        .success()
        .stdout(predicate::str::contains("Cleared 2 failed post(s)"));

    // Verify they're gone
    let mut cmd = Command::cargo_bin("plur-queue").unwrap();
    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("list")
        .assert()
        .success()
        .stdout(predicate::str::contains("No failed posts"));
}

#[tokio::test]
async fn test_workflow_list_then_delete_specific() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    // Create failed posts
    let delete_id = create_failed_post(&db_path, "Failed post to delete").await;
    create_failed_post(&db_path, "Failed post to keep").await;

    // List to see both
    let mut cmd = Command::cargo_bin("plur-queue").unwrap();
    let output = cmd
        .env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("list")
        .assert()
        .success()
        .get_output()
        .stdout
        .clone();

    let stdout = String::from_utf8(output).unwrap();
    assert!(stdout.contains("Failed post to delete"));
    assert!(stdout.contains("Failed post to keep"));

    // Delete specific one
    let mut cmd = Command::cargo_bin("plur-queue").unwrap();
    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("delete")
        .arg(&delete_id)
        .arg("--force")
        .assert()
        .success();

    // List again, should only see the one we kept
    let mut cmd = Command::cargo_bin("plur-queue").unwrap();
    let output = cmd
        .env("PLURCAST_CONFIG", &config_path)
        .arg("failed")
        .arg("list")
        .assert()
        .success()
        .get_output()
        .stdout
        .clone();

    let stdout = String::from_utf8(output).unwrap();
    assert!(!stdout.contains("Failed post to delete"));
    assert!(stdout.contains("Failed post to keep"));
}
