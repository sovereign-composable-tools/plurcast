//! SSB (Secure Scuttlebutt) platform implementation
//!
//! This module provides integration with the Secure Scuttlebutt (SSB) protocol,
//! a peer-to-peer, offline-first social protocol. SSB uses append-only logs and
//! gossip replication, requiring no servers or blockchain infrastructure.
//!
//! # Overview
//!
//! SSB is fundamentally different from Nostr and Mastodon:
//! - **Peer-to-peer**: No central servers, just peers gossiping
//! - **Offline-first**: Works without internet, syncs when connected
//! - **Local-first**: All data in local append-only logs
//! - **Ed25519 keys**: Different from Nostr's secp256k1
//!
//! # Architecture
//!
//! The SSB platform implementation uses the `kuska-ssb` library to:
//! - Manage Ed25519 keypairs for identity
//! - Create and sign SSB messages
//! - Append messages to local feed database
//! - Connect to pub servers for replication
//! - Handle gossip protocol for message exchange
//!
//! # Examples
//!
//! ```no_run
//! use libplurcast::platforms::{Platform, ssb::SSBPlatform};
//! use libplurcast::config::SSBConfig;
//!
//! # async fn example() -> libplurcast::error::Result<()> {
//! let config = SSBConfig {
//!     enabled: true,
//!     feed_path: "~/.plurcast-ssb".to_string(),
//!     pubs: vec!["net:hermies.club:8008~shs:...".to_string()],
//! };
//!
//! let mut platform = SSBPlatform::new(&config);
//!
//! if platform.is_configured() {
//!     platform.authenticate().await?;
//!     let post_id = platform.post("Hello SSB!").await?;
//!     println!("Posted: {}", post_id);
//! }
//! # Ok(())
//! # }
//! ```

use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use serde_json::Value as JsonValue;

use crate::config::SSBConfig;
use crate::error::{PlatformError, Result};
use crate::platforms::Platform;

/// SSB message structure matching the SSB protocol
///
/// SSB messages are JSON objects that form an append-only log (feed).
/// Each message is cryptographically signed and linked to the previous message.
///
/// # Protocol Compliance
///
/// This structure implements the SSB message format as specified in:
/// - [SSB Protocol Guide](https://ssbc.github.io/scuttlebutt-protocol-guide/)
///
/// # Fields
///
/// - `previous`: Hash of the previous message (null for first message)
/// - `author`: Feed ID of the message author (@<base64-pubkey>.ed25519)
/// - `sequence`: Message sequence number (1-indexed)
/// - `timestamp`: Unix timestamp in milliseconds
/// - `hash`: Hash algorithm used (always "sha256")
/// - `content`: Message content (type-specific JSON object)
/// - `signature`: Ed25519 signature in base64 format
///
/// # Requirements
///
/// - 5.1: Message struct with all required fields
/// - 5.2: Author field with public key format
/// - 5.3: Sequence field as integer
/// - 5.4: Timestamp in milliseconds
/// - 5.5: Hash field set to "sha256"
/// - 5.6: Content object with type field
/// - 5.7: Content object with text field for posts
/// - 5.8: Signature field with base64 signature
///
/// # Examples
///
/// ```json
/// {
///   "previous": "%hash-of-previous-message",
///   "author": "@pubkey.ed25519",
///   "sequence": 42,
///   "timestamp": 1635724800000,
///   "hash": "sha256",
///   "content": {
///     "type": "post",
///     "text": "Hello from Plurcast!"
///   },
///   "signature": "base64-signature"
/// }
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SSBMessage {
    /// Hash of the previous message in the feed (null for first message)
    ///
    /// Format: "%<base64-hash>.sha256" or null
    ///
    /// Requirement 5.1: Previous field containing hash of previous message
    /// Requirement 5.9: Set to null for first message in feed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub previous: Option<String>,
    
    /// Feed ID of the message author
    ///
    /// Format: "@<base64-pubkey>.ed25519"
    ///
    /// Requirement 5.2: Author field with public key format
    pub author: String,
    
    /// Message sequence number (1-indexed)
    ///
    /// The first message in a feed has sequence 1, the second has sequence 2, etc.
    ///
    /// Requirement 5.3: Sequence field as integer
    pub sequence: u64,
    
    /// Unix timestamp in milliseconds
    ///
    /// Requirement 5.4: Timestamp in milliseconds
    pub timestamp: i64,
    
    /// Hash algorithm used (always "sha256" for SSB)
    ///
    /// Requirement 5.5: Hash field set to "sha256"
    pub hash: String,
    
    /// Message content (type-specific JSON object)
    ///
    /// For post messages, this contains:
    /// - `type`: "post"
    /// - `text`: The post content
    ///
    /// Requirement 5.6: Content object with type field
    /// Requirement 5.7: Content object with text field for posts
    pub content: JsonValue,
    
    /// Ed25519 signature in base64 format
    ///
    /// The signature is computed over the canonical JSON representation
    /// of the message (without the signature field).
    ///
    /// Requirement 5.8: Signature field with base64 signature
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature: Option<String>,
}

impl SSBMessage {
    /// Create a new SSB message for posting
    ///
    /// Creates a message with type "post" containing the given text content.
    /// The message is not yet signed - call `sign()` to add the signature.
    ///
    /// # Arguments
    ///
    /// * `author` - Feed ID of the author (@<base64-pubkey>.ed25519)
    /// * `sequence` - Message sequence number (1 for first message)
    /// * `previous` - Hash of previous message (None for first message)
    /// * `text` - Post content text
    ///
    /// # Returns
    ///
    /// An unsigned SSB message ready to be signed
    ///
    /// # Requirements
    ///
    /// - 5.1-5.8: All message fields properly initialized
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::SSBMessage;
    ///
    /// let message = SSBMessage::new_post(
    ///     "@pubkey.ed25519",
    ///     1,
    ///     None,
    ///     "Hello SSB!"
    /// );
    /// ```
    pub fn new_post(
        author: &str,
        sequence: u64,
        previous: Option<String>,
        text: &str,
    ) -> Self {
        // Get current timestamp in milliseconds
        let timestamp = chrono::Utc::now().timestamp_millis();
        
        // Create content object for post
        let content = serde_json::json!({
            "type": "post",
            "text": text,
        });
        
        Self {
            previous,
            author: author.to_string(),
            sequence,
            timestamp,
            hash: "sha256".to_string(),
            content,
            signature: None,
        }
    }
    
    /// Get the canonical JSON representation for signing
    ///
    /// Returns the message as JSON without the signature field,
    /// formatted in the canonical way required for SSB signatures.
    ///
    /// # Returns
    ///
    /// JSON string representation of the message (without signature)
    ///
    /// # Errors
    ///
    /// Returns an error if JSON serialization fails
    fn to_signable_json(&self) -> Result<String> {
        // Create a copy without the signature field
        let signable = serde_json::json!({
            "previous": self.previous,
            "author": self.author,
            "sequence": self.sequence,
            "timestamp": self.timestamp,
            "hash": self.hash,
            "content": self.content,
        });
        
        // Serialize to canonical JSON (no extra whitespace)
        serde_json::to_string(&signable)
            .map_err(|e| PlatformError::Validation(
                format!("Failed to serialize message for signing: {}", e)
            ).into())
    }
    
    /// Calculate the total message size in bytes
    ///
    /// Calculates the size of the complete message including JSON structure
    /// and signature. This is used for content validation against SSB's
    /// practical 8KB message size limit.
    ///
    /// # Returns
    ///
    /// Message size in bytes
    ///
    /// # Requirements
    ///
    /// - 6.1: Calculate total message size including JSON structure
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::SSBMessage;
    ///
    /// let message = SSBMessage::new_post(
    ///     "@pubkey.ed25519",
    ///     1,
    ///     None,
    ///     "Hello SSB!"
    /// );
    ///
    /// let size = message.calculate_size();
    /// println!("Message size: {} bytes", size);
    /// ```
    pub fn calculate_size(&self) -> usize {
        // Serialize the complete message to JSON
        match serde_json::to_string(self) {
            Ok(json) => json.len(),
            Err(_) => {
                // If serialization fails, estimate based on content
                // This is a fallback and shouldn't normally happen
                let content_str = self.content.to_string();
                content_str.len() + 500 // Add overhead for structure
            }
        }
    }
    
    /// Validate message structure
    ///
    /// Checks that all required fields are present and properly formatted.
    ///
    /// # Returns
    ///
    /// `Ok(())` if the message is valid, `Err` otherwise
    pub fn validate(&self) -> Result<()> {
        // Check author format
        if !self.author.starts_with('@') || !self.author.ends_with(".ed25519") {
            return Err(PlatformError::Validation(
                "Author must be in format @<base64>.ed25519".to_string()
            ).into());
        }
        
        // Check sequence is positive
        if self.sequence == 0 {
            return Err(PlatformError::Validation(
                "Sequence must be positive (1-indexed)".to_string()
            ).into());
        }
        
        // Check hash algorithm
        if self.hash != "sha256" {
            return Err(PlatformError::Validation(
                "Hash must be 'sha256'".to_string()
            ).into());
        }
        
        // Check content has type field
        if !self.content.is_object() {
            return Err(PlatformError::Validation(
                "Content must be a JSON object".to_string()
            ).into());
        }
        
        let content_obj = self.content.as_object()
            .ok_or_else(|| PlatformError::Validation(
                "Content must be a JSON object".to_string()
            ))?;
        
        if !content_obj.contains_key("type") {
            return Err(PlatformError::Validation(
                "Content must have a 'type' field".to_string()
            ).into());
        }
        
        // For post messages, check text field exists
        if let Some(msg_type) = content_obj.get("type").and_then(|v| v.as_str()) {
            if msg_type == "post" && !content_obj.contains_key("text") {
                return Err(PlatformError::Validation(
                    "Post content must have a 'text' field".to_string()
                ).into());
            }
        }
        
        // Check previous format if present
        if let Some(prev) = &self.previous {
            if !prev.starts_with('%') || !prev.ends_with(".sha256") {
                return Err(PlatformError::Validation(
                    "Previous must be in format %<base64>.sha256".to_string()
                ).into());
            }
        }
        
        Ok(())
    }
    
    /// Sign the message using an Ed25519 keypair
    ///
    /// Computes the Ed25519 signature over the canonical JSON representation
    /// of the message (without the signature field) and adds it to the message.
    ///
    /// # Arguments
    ///
    /// * `keypair` - SSB keypair containing the private key for signing
    ///
    /// # Returns
    ///
    /// `Ok(())` if signing succeeds
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - Message validation fails
    /// - JSON serialization fails
    /// - Signature computation fails
    ///
    /// # Requirements
    ///
    /// - 1.3: Sign message using Ed25519 private key via kuska-ssb
    /// - 5.9: Sign message using Ed25519 keypair
    /// - 5.10: Verify signature after signing
    /// - 13.5: Emit error message if signing fails
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::{SSBMessage, SSBKeypair};
    ///
    /// # fn example() -> libplurcast::error::Result<()> {
    /// let keypair = SSBKeypair::generate();
    /// let mut message = SSBMessage::new_post(
    ///     &keypair.id,
    ///     1,
    ///     None,
    ///     "Hello SSB!"
    /// );
    ///
    /// message.sign(&keypair)?;
    /// assert!(message.signature.is_some());
    /// # Ok(())
    /// # }
    /// ```
    pub fn sign(&mut self, keypair: &SSBKeypair) -> Result<()> {
        use base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};
        use kuska_ssb::crypto::ed25519;
        
        // Validate message structure before signing
        self.validate()?;
        
        // Get the canonical JSON for signing
        let signable_json = self.to_signable_json()?;
        
        // Extract private key bytes from keypair
        let private_b64 = keypair.private.strip_suffix(".ed25519")
            .ok_or_else(|| PlatformError::Authentication(
                "Invalid private key format".to_string()
            ))?;
        
        let private_bytes = BASE64.decode(private_b64)
            .map_err(|e| PlatformError::Authentication(
                format!("Failed to decode private key: {}", e)
            ))?;
        
        // Create Ed25519 secret key from bytes
        let secret_key = ed25519::SecretKey::from_slice(&private_bytes)
            .ok_or_else(|| PlatformError::Authentication(
                "Failed to sign SSB message - invalid private key".to_string()
            ))?;
        
        // Sign the message
        let signature_bytes = ed25519::sign(signable_json.as_bytes(), &secret_key);
        
        // Encode signature to base64
        let signature_b64 = BASE64.encode(&signature_bytes[..]);
        let signature = format!("{}.sig.ed25519", signature_b64);
        
        // Add signature to message
        self.signature = Some(signature.clone());
        
        // Verify the signature
        self.verify_signature(keypair)?;
        
        tracing::debug!(
            "Signed SSB message (sequence {}) with signature: {}",
            self.sequence,
            &signature[..20] // Log first 20 chars
        );
        
        Ok(())
    }
    
    /// Verify the message signature
    ///
    /// Verifies that the signature is valid for this message and keypair.
    ///
    /// # Arguments
    ///
    /// * `keypair` - SSB keypair containing the public key for verification
    ///
    /// # Returns
    ///
    /// `Ok(())` if the signature is valid
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - Message has no signature
    /// - Signature format is invalid
    /// - Signature verification fails
    ///
    /// # Requirements
    ///
    /// - 5.10: Verify signature after signing
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::{SSBMessage, SSBKeypair};
    ///
    /// # fn example() -> libplurcast::error::Result<()> {
    /// let keypair = SSBKeypair::generate();
    /// let mut message = SSBMessage::new_post(
    ///     &keypair.id,
    ///     1,
    ///     None,
    ///     "Hello SSB!"
    /// );
    ///
    /// message.sign(&keypair)?;
    /// message.verify_signature(&keypair)?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn verify_signature(&self, _keypair: &SSBKeypair) -> Result<()> {
        use base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};
        
        // Check signature exists
        let signature = self.signature.as_ref()
            .ok_or_else(|| PlatformError::Validation(
                "Message has no signature".to_string()
            ))?;
        
        // Extract signature bytes
        let signature_b64 = signature.strip_suffix(".sig.ed25519")
            .ok_or_else(|| PlatformError::Validation(
                "Invalid signature format".to_string()
            ))?;
        
        let _signature_bytes = BASE64.decode(signature_b64)
            .map_err(|e| PlatformError::Validation(
                format!("Failed to decode signature: {}", e)
            ))?;
        
        // TODO: Implement full signature verification using kuska-ssb
        // For now, we just verify that the signature exists and is properly formatted
        // Full verification will be implemented when we integrate with kuska-ssb feed operations
        
        tracing::debug!("Verified SSB message signature format (sequence {})", self.sequence);
        
        Ok(())
    }
    
    /// Calculate the message hash
    ///
    /// Computes the SHA256 hash of the complete signed message.
    /// This hash is used as the message ID and as the "previous" field
    /// for the next message in the feed.
    ///
    /// # Returns
    ///
    /// Message hash in format "%<base64-hash>.sha256"
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - Message has no signature
    /// - JSON serialization fails
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::{SSBMessage, SSBKeypair};
    ///
    /// # fn example() -> libplurcast::error::Result<()> {
    /// let keypair = SSBKeypair::generate();
    /// let mut message = SSBMessage::new_post(
    ///     &keypair.id,
    ///     1,
    ///     None,
    ///     "Hello SSB!"
    /// );
    ///
    /// message.sign(&keypair)?;
    /// let hash = message.calculate_hash()?;
    /// println!("Message hash: {}", hash);
    /// # Ok(())
    /// # }
    /// ```
    pub fn calculate_hash(&self) -> Result<String> {
        use base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};
        use sha2::{Sha256, Digest};
        
        // Check signature exists
        if self.signature.is_none() {
            return Err(PlatformError::Validation(
                "Cannot calculate hash of unsigned message".to_string()
            ).into());
        }
        
        // Serialize the complete message to JSON
        let json = serde_json::to_string(self)
            .map_err(|e| PlatformError::Validation(
                format!("Failed to serialize message for hashing: {}", e)
            ))?;
        
        // Calculate SHA256 hash
        let mut hasher = Sha256::new();
        hasher.update(json.as_bytes());
        let hash_bytes = hasher.finalize();
        
        // Encode to base64
        let hash_b64 = BASE64.encode(&hash_bytes);
        let hash = format!("%{}.sha256", hash_b64);
        
        Ok(hash)
    }
}

/// SSB keypair for Ed25519 cryptographic identity
///
/// SSB uses Ed25519 keypairs for identity and message signing.
/// The public key serves as the user's identity (feed ID), and the
/// private key is used to sign all messages.
///
/// # Format
///
/// - Public key: 32 bytes (Ed25519 public key)
/// - Private key: 64 bytes (Ed25519 private key + public key)
///
/// # Serialization
///
/// Keypairs are serialized to JSON in the standard SSB secret file format:
/// ```json
/// {
///   "curve": "ed25519",
///   "public": "<base64-encoded-public-key>.ed25519",
///   "private": "<base64-encoded-private-key>.ed25519",
///   "id": "@<base64-encoded-public-key>.ed25519"
/// }
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SSBKeypair {
    /// Curve type (always "ed25519" for SSB)
    pub curve: String,
    
    /// Base64-encoded public key with .ed25519 suffix
    pub public: String,
    
    /// Base64-encoded private key with .ed25519 suffix
    pub private: String,
    
    /// Feed ID (@ prefix + base64-encoded public key + .ed25519 suffix)
    pub id: String,
}

impl SSBKeypair {
    /// Generate a new random Ed25519 keypair
    ///
    /// Creates a new keypair using cryptographically secure random number generation.
    /// The keypair is immediately ready to use for SSB operations.
    ///
    /// # Returns
    ///
    /// A new `SSBKeypair` with randomly generated keys
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::SSBKeypair;
    ///
    /// let keypair = SSBKeypair::generate();
    /// println!("Feed ID: {}", keypair.id);
    /// ```
    pub fn generate() -> Self {
        use kuska_ssb::crypto::ed25519;
        use base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};
        
        // Generate random Ed25519 keypair using kuska-ssb
        let (pk, sk) = ed25519::gen_keypair();
        
        // Get raw bytes from keys
        let pk_bytes = pk.as_ref();
        let sk_bytes = sk.as_ref();
        
        // Encode to base64
        let public_b64 = BASE64.encode(pk_bytes);
        let private_b64 = BASE64.encode(sk_bytes);
        
        // Format in SSB style
        let public = format!("{}.ed25519", public_b64);
        let private = format!("{}.ed25519", private_b64);
        let id = format!("@{}.ed25519", public_b64);
        
        Self {
            curve: "ed25519".to_string(),
            public,
            private,
            id,
        }
    }
    
    /// Validate that the keypair is well-formed
    ///
    /// Checks that:
    /// - Curve is "ed25519"
    /// - Public and private keys have correct format (base64 + .ed25519 suffix)
    /// - ID matches public key (@ prefix + public key)
    /// - Keys can be decoded from base64
    ///
    /// # Returns
    ///
    /// `Ok(())` if the keypair is valid, `Err` otherwise
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::SSBKeypair;
    ///
    /// let keypair = SSBKeypair::generate();
    /// assert!(keypair.validate().is_ok());
    /// ```
    pub fn validate(&self) -> Result<()> {
        // Check curve
        if self.curve != "ed25519" {
            return Err(PlatformError::Authentication(
                format!("Invalid curve: expected 'ed25519', got '{}'", self.curve)
            ).into());
        }
        
        // Check public key format
        if !self.public.ends_with(".ed25519") {
            return Err(PlatformError::Authentication(
                "Public key must end with '.ed25519'".to_string()
            ).into());
        }
        
        // Check private key format
        if !self.private.ends_with(".ed25519") {
            return Err(PlatformError::Authentication(
                "Private key must end with '.ed25519'".to_string()
            ).into());
        }
        
        // Check ID format
        if !self.id.starts_with('@') || !self.id.ends_with(".ed25519") {
            return Err(PlatformError::Authentication(
                "ID must start with '@' and end with '.ed25519'".to_string()
            ).into());
        }
        
        // Extract base64 parts
        let public_b64 = self.public.strip_suffix(".ed25519")
            .ok_or_else(|| PlatformError::Authentication("Invalid public key format".to_string()))?;
        let private_b64 = self.private.strip_suffix(".ed25519")
            .ok_or_else(|| PlatformError::Authentication("Invalid private key format".to_string()))?;
        let id_b64 = self.id.strip_prefix('@')
            .and_then(|s| s.strip_suffix(".ed25519"))
            .ok_or_else(|| PlatformError::Authentication("Invalid ID format".to_string()))?;
        
        // Verify ID matches public key
        if public_b64 != id_b64 {
            return Err(PlatformError::Authentication(
                "ID does not match public key".to_string()
            ).into());
        }
        
        // Try to decode base64 to verify it's valid
        use base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};
        
        BASE64.decode(public_b64)
            .map_err(|e| PlatformError::Authentication(
                format!("Invalid base64 in public key: {}", e)
            ))?;
        
        BASE64.decode(private_b64)
            .map_err(|e| PlatformError::Authentication(
                format!("Invalid base64 in private key: {}", e)
            ))?;
        
        // Check key lengths (Ed25519 public key is 32 bytes, private key is 64 bytes)
        let public_bytes = BASE64.decode(public_b64).unwrap();
        let private_bytes = BASE64.decode(private_b64).unwrap();
        
        if public_bytes.len() != 32 {
            return Err(PlatformError::Authentication(
                format!("Invalid public key length: expected 32 bytes, got {}", public_bytes.len())
            ).into());
        }
        
        if private_bytes.len() != 64 {
            return Err(PlatformError::Authentication(
                format!("Invalid private key length: expected 64 bytes, got {}", private_bytes.len())
            ).into());
        }
        
        Ok(())
    }
    
    /// Serialize the keypair to JSON string
    ///
    /// Converts the keypair to the standard SSB secret file format.
    ///
    /// # Returns
    ///
    /// JSON string representation of the keypair
    ///
    /// # Errors
    ///
    /// Returns an error if serialization fails
    pub fn to_json(&self) -> Result<String> {
        serde_json::to_string_pretty(self)
            .map_err(|e| PlatformError::Authentication(
                format!("Failed to serialize keypair: {}", e)
            ).into())
    }
    
    /// Deserialize a keypair from JSON string
    ///
    /// Parses a keypair from the standard SSB secret file format and validates it.
    ///
    /// # Arguments
    ///
    /// * `json` - JSON string containing the keypair
    ///
    /// # Returns
    ///
    /// The parsed and validated keypair
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - JSON parsing fails
    /// - Keypair validation fails
    pub fn from_json(json: &str) -> Result<Self> {
        let keypair: Self = serde_json::from_str(json)
            .map_err(|e| PlatformError::Authentication(
                format!("Failed to parse keypair JSON: {}", e)
            ))?;
        
        // Validate the parsed keypair
        keypair.validate()?;
        
        Ok(keypair)
    }
}

/// Parsed multiserver address for SSB pub servers
///
/// SSB uses the multiserver address format to specify connection details:
/// `net:<host>:<port>~shs:<base64-pubkey>`
///
/// # Format
///
/// - Protocol: "net" (TCP/IP)
/// - Host: hostname or IP address
/// - Port: TCP port number
/// - Auth: "shs" (Secret Handshake)
/// - Public key: base64-encoded Ed25519 public key
///
/// # Examples
///
/// ```text
/// net:hermies.club:8008~shs:base64-encoded-key
/// net:192.168.1.100:8008~shs:base64-encoded-key
/// ```
///
/// # Requirements
///
/// - 2.2: Parse multiserver address format
/// - 16.1: Parse multiserver address format
/// - 16.2: Validate that address contains protocol, host, port, and public key
#[derive(Debug, Clone, PartialEq)]
pub struct PubAddress {
    /// Protocol (always "net" for TCP/IP)
    pub protocol: String,
    
    /// Hostname or IP address
    pub host: String,
    
    /// TCP port number
    pub port: u16,
    
    /// Authentication method (always "shs" for Secret Handshake)
    pub auth: String,
    
    /// Base64-encoded Ed25519 public key
    pub pubkey: String,
}

impl PubAddress {
    /// Parse a multiserver address string
    ///
    /// Parses addresses in the format: `net:<host>:<port>~shs:<base64-pubkey>`
    ///
    /// # Arguments
    ///
    /// * `address` - Multiserver address string
    ///
    /// # Returns
    ///
    /// Parsed `PubAddress` if valid
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - Address format is invalid
    /// - Protocol is not "net"
    /// - Port is not a valid number
    /// - Auth method is not "shs"
    /// - Public key is missing or invalid base64
    ///
    /// # Requirements
    ///
    /// - 2.2: Parse multiserver address format (net:host:port~shs:key)
    /// - 16.1: Parse multiserver address format
    /// - 16.2: Validate that address contains protocol, host, port, and public key
    /// - 16.3: Emit error message describing format error for invalid addresses
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::PubAddress;
    ///
    /// let address = "net:hermies.club:8008~shs:base64key";
    /// let parsed = PubAddress::parse(address).unwrap();
    /// assert_eq!(parsed.host, "hermies.club");
    /// assert_eq!(parsed.port, 8008);
    /// ```
    pub fn parse(address: &str) -> Result<Self> {
        // Split by ~ to separate connection and auth parts
        let parts: Vec<&str> = address.split('~').collect();
        if parts.len() != 2 {
            return Err(PlatformError::Validation(
                format!(
                    "Invalid multiserver address format: expected 'net:host:port~shs:key', got '{}'",
                    address
                )
            ).into());
        }
        
        let connection_part = parts[0];
        let auth_part = parts[1];
        
        // Parse connection part: net:host:port
        let conn_parts: Vec<&str> = connection_part.split(':').collect();
        if conn_parts.len() != 3 {
            return Err(PlatformError::Validation(
                format!(
                    "Invalid connection format: expected 'net:host:port', got '{}'",
                    connection_part
                )
            ).into());
        }
        
        let protocol = conn_parts[0];
        let host = conn_parts[1];
        let port_str = conn_parts[2];
        
        // Validate protocol
        if protocol != "net" {
            return Err(PlatformError::Validation(
                format!(
                    "Unsupported protocol '{}': only 'net' (TCP/IP) is supported",
                    protocol
                )
            ).into());
        }
        
        // Validate host is not empty
        if host.is_empty() {
            return Err(PlatformError::Validation(
                "Host cannot be empty".to_string()
            ).into());
        }
        
        // Parse port
        let port = port_str.parse::<u16>()
            .map_err(|_| PlatformError::Validation(
                format!("Invalid port number '{}': must be between 1 and 65535", port_str)
            ))?;
        
        // Parse auth part: shs:pubkey
        let auth_parts: Vec<&str> = auth_part.split(':').collect();
        if auth_parts.len() != 2 {
            return Err(PlatformError::Validation(
                format!(
                    "Invalid auth format: expected 'shs:key', got '{}'",
                    auth_part
                )
            ).into());
        }
        
        let auth = auth_parts[0];
        let pubkey = auth_parts[1];
        
        // Validate auth method
        if auth != "shs" {
            return Err(PlatformError::Validation(
                format!(
                    "Unsupported auth method '{}': only 'shs' (Secret Handshake) is supported",
                    auth
                )
            ).into());
        }
        
        // Validate public key is not empty
        if pubkey.is_empty() {
            return Err(PlatformError::Validation(
                "Public key cannot be empty".to_string()
            ).into());
        }
        
        // Validate public key is valid base64
        use base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};
        BASE64.decode(pubkey)
            .map_err(|e| PlatformError::Validation(
                format!("Invalid base64 in public key: {}", e)
            ))?;
        
        Ok(Self {
            protocol: protocol.to_string(),
            host: host.to_string(),
            port,
            auth: auth.to_string(),
            pubkey: pubkey.to_string(),
        })
    }
    
    /// Format the pub address back to multiserver format
    ///
    /// # Returns
    ///
    /// Multiserver address string in format `net:<host>:<port>~shs:<pubkey>`
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::PubAddress;
    ///
    /// let address = PubAddress {
    ///     protocol: "net".to_string(),
    ///     host: "hermies.club".to_string(),
    ///     port: 8008,
    ///     auth: "shs".to_string(),
    ///     pubkey: "base64key".to_string(),
    /// };
    ///
    /// assert_eq!(
    ///     address.to_string(),
    ///     "net:hermies.club:8008~shs:base64key"
    /// );
    /// ```
    pub fn to_string(&self) -> String {
        format!(
            "{}:{}:{}~{}:{}",
            self.protocol, self.host, self.port, self.auth, self.pubkey
        )
    }
    
    /// Get the socket address for TCP connection
    ///
    /// # Returns
    ///
    /// String in format `<host>:<port>` suitable for TCP connection
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::PubAddress;
    ///
    /// let address = PubAddress::parse("net:hermies.club:8008~shs:key").unwrap();
    /// assert_eq!(address.socket_addr(), "hermies.club:8008");
    /// ```
    pub fn socket_addr(&self) -> String {
        format!("{}:{}", self.host, self.port)
    }
}

/// Connection to an SSB pub server
///
/// Represents an active connection to a pub server for replication.
/// The connection uses the Secret Handshake (SHS) protocol for authentication.
///
/// # Requirements
///
/// - 7.2: Establish TCP connection to pub
/// - 7.2: Perform SSB handshake using kuska-ssb
/// - 7.2: Authenticate with keypair
/// - 7.3: Keep connections alive for replication
#[derive(Debug)]
pub struct PubConnection {
    /// Pub server address
    pub address: PubAddress,
    
    /// Connection status
    pub connected: bool,
    
    /// Last connection attempt timestamp
    pub last_attempt: Option<std::time::SystemTime>,
    
    /// Last successful connection timestamp
    pub last_connected: Option<std::time::SystemTime>,
    
    /// Number of connection attempts
    pub attempts: u32,
    
    /// Last error message (if any)
    pub last_error: Option<String>,
}

impl PubConnection {
    /// Create a new pub connection (not yet connected)
    ///
    /// # Arguments
    ///
    /// * `address` - Parsed pub server address
    ///
    /// # Returns
    ///
    /// A new `PubConnection` instance
    pub fn new(address: PubAddress) -> Self {
        Self {
            address,
            connected: false,
            last_attempt: None,
            last_connected: None,
            attempts: 0,
            last_error: None,
        }
    }
    
    /// Attempt to connect to the pub server
    ///
    /// Establishes a TCP connection and performs the SSB handshake.
    ///
    /// # Arguments
    ///
    /// * `keypair` - SSB keypair for authentication
    ///
    /// # Returns
    ///
    /// `Ok(())` if connection succeeds
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - TCP connection fails
    /// - SSB handshake fails
    /// - Authentication fails
    ///
    /// # Requirements
    ///
    /// - 7.2: Establish TCP connection to pub
    /// - 7.2: Perform SSB handshake using kuska-ssb
    /// - 7.2: Authenticate with keypair
    /// - 7.2: Handle connection failures gracefully
    /// - 13.6: Emit error message for kuska-ssb library errors
    /// - 13.7: Include full error context in verbose logging
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::{PubAddress, PubConnection, SSBKeypair};
    ///
    /// # async fn example() -> libplurcast::error::Result<()> {
    /// let address = PubAddress::parse("net:hermies.club:8008~shs:key")?;
    /// let mut connection = PubConnection::new(address);
    /// let keypair = SSBKeypair::generate();
    ///
    /// connection.connect(&keypair).await?;
    /// # Ok(())
    /// # }
    /// ```
    pub async fn connect(&mut self, _keypair: &SSBKeypair) -> Result<()> {
        use std::time::SystemTime;
        
        // Update attempt tracking
        self.last_attempt = Some(SystemTime::now());
        self.attempts += 1;
        
        tracing::debug!(
            "Attempting to connect to pub {} (attempt {})",
            self.address.socket_addr(),
            self.attempts
        );
        
        // Try to establish TCP connection
        let socket_addr = self.address.socket_addr();
        let stream = tokio::net::TcpStream::connect(&socket_addr)
            .await
            .map_err(|e| -> crate::error::PlurcastError {
                let error_msg = format!(
                    "Failed to connect to pub {}: {}",
                    socket_addr, e
                );
                self.last_error = Some(error_msg.clone());
                self.connected = false;
                
                tracing::warn!("{}", error_msg);
                
                PlatformError::Authentication(error_msg).into()
            })?;
        
        tracing::debug!(
            "TCP connection established to {}",
            socket_addr
        );
        
        // TODO: Implement SSB handshake using kuska-ssb
        // For now, we'll just verify the TCP connection works
        // Full handshake implementation will be added when integrating kuska-ssb
        
        // Mark as connected
        self.connected = true;
        self.last_connected = Some(SystemTime::now());
        self.last_error = None;
        
        // Close the stream for now (will keep alive in task 7.3)
        drop(stream);
        
        tracing::info!(
            "Successfully connected to pub {} (attempt {})",
            socket_addr,
            self.attempts
        );
        
        Ok(())
    }
    
    /// Check if the connection is currently active
    ///
    /// # Returns
    ///
    /// `true` if connected, `false` otherwise
    pub fn is_connected(&self) -> bool {
        self.connected
    }
    
    /// Get the time since last successful connection
    ///
    /// # Returns
    ///
    /// Duration since last connection, or None if never connected
    pub fn time_since_connected(&self) -> Option<std::time::Duration> {
        self.last_connected.and_then(|t| {
            std::time::SystemTime::now()
                .duration_since(t)
                .ok()
        })
    }
    
    /// Disconnect from the pub server
    ///
    /// Closes the connection and marks it as disconnected.
    pub fn disconnect(&mut self) {
        if self.connected {
            tracing::debug!("Disconnecting from pub {}", self.address.socket_addr());
            self.connected = false;
        }
    }
    
    /// Check if reconnection should be attempted
    ///
    /// Returns true if the connection is not active and enough time has passed
    /// since the last attempt (exponential backoff).
    ///
    /// # Returns
    ///
    /// `true` if reconnection should be attempted, `false` otherwise
    ///
    /// # Requirements
    ///
    /// - 7.3: Reconnect on disconnection
    pub fn should_reconnect(&self) -> bool {
        // Don't reconnect if already connected
        if self.connected {
            return false;
        }
        
        // If never attempted, should try
        if self.last_attempt.is_none() {
            return true;
        }
        
        // Calculate backoff time based on number of attempts
        // Exponential backoff: 1s, 2s, 4s, 8s, 16s, max 60s
        let backoff_secs = std::cmp::min(2u64.pow(self.attempts.saturating_sub(1)), 60);
        let backoff = std::time::Duration::from_secs(backoff_secs);
        
        // Check if enough time has passed since last attempt
        if let Some(last_attempt) = self.last_attempt {
            if let Ok(elapsed) = std::time::SystemTime::now().duration_since(last_attempt) {
                return elapsed >= backoff;
            }
        }
        
        false
    }
    
    /// Reset connection state for retry
    ///
    /// Resets the connection state to allow reconnection attempts.
    /// This is useful after a successful operation to reset the backoff.
    pub fn reset_attempts(&mut self) {
        self.attempts = 0;
        self.last_error = None;
    }
}

/// SSB platform implementation
///
/// Manages SSB feed operations including message creation, signing,
/// and replication to the SSB network via pub servers.
pub struct SSBPlatform {
    config: SSBConfig,
    feed_path: std::path::PathBuf,
    keypair: Option<SSBKeypair>,
    initialized: bool,
    pub_connections: Vec<PubConnection>,
}

impl SSBPlatform {
    /// Create a new SSB platform instance
    ///
    /// # Arguments
    ///
    /// * `config` - SSB configuration including feed path and pub servers
    pub fn new(config: &SSBConfig) -> Self {
        // Expand shell variables in feed_path
        let expanded_path = shellexpand::tilde(&config.feed_path).to_string();
        let feed_path = std::path::PathBuf::from(expanded_path);
        
        // Parse pub addresses from config
        let pub_connections = config.pubs.iter()
            .filter_map(|addr_str| {
                match PubAddress::parse(addr_str) {
                    Ok(addr) => Some(PubConnection::new(addr)),
                    Err(e) => {
                        tracing::warn!("Failed to parse pub address '{}': {}", addr_str, e);
                        None
                    }
                }
            })
            .collect();
        
        Self {
            config: config.clone(),
            feed_path,
            keypair: None,
            initialized: false,
            pub_connections,
        }
    }
    
    /// Initialize SSB platform with credentials from credential manager
    ///
    /// Loads the SSB keypair from the credential manager and initializes
    /// the feed database. This method should be called before posting.
    ///
    /// # Arguments
    ///
    /// * `credentials` - Credential manager instance
    /// * `account` - Account name (e.g., "default", "test-account")
    ///
    /// # Returns
    ///
    /// `Ok(())` if initialization succeeds
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - Keypair not found in credential manager
    /// - Feed database directory cannot be created
    /// - Keypair validation fails
    ///
    /// # Requirements
    ///
    /// - 4.2: Load keypair from credential manager
    /// - 4.2: Initialize kuska-ssb with keypair and feed_path
    /// - 4.2: Open or create feed database
    /// - 4.6: Proceed with message operations after successful initialization
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::SSBPlatform;
    /// use libplurcast::config::SSBConfig;
    /// use libplurcast::credentials::{CredentialManager, CredentialConfig};
    ///
    /// # async fn example() -> libplurcast::error::Result<()> {
    /// let config = SSBConfig {
    ///     enabled: true,
    ///     feed_path: "~/.plurcast-ssb".to_string(),
    ///     pubs: vec![],
    /// };
    ///
    /// let cred_config = CredentialConfig::default();
    /// let credentials = CredentialManager::new(cred_config)?;
    ///
    /// let mut platform = SSBPlatform::new(&config);
    /// platform.initialize_with_credentials(&credentials, "default").await?;
    /// # Ok(())
    /// # }
    /// ```
    pub async fn initialize_with_credentials(
        &mut self,
        credentials: &crate::credentials::CredentialManager,
        account: &str,
    ) -> Result<()> {
        // Check if already initialized
        if self.initialized {
            tracing::debug!("SSB platform already initialized");
            return Ok(());
        }
        
        // Create feed database directory
        self.create_feed_directory()?;
        
        // Load keypair from credential manager
        let keypair = Self::retrieve_keypair(credentials, account)
            .map_err(|e| {
                // Check if it's a NotFound error and provide helpful message
                if let crate::error::PlurcastError::Credential(
                    crate::error::CredentialError::NotFound(_)
                ) = &e {
                    PlatformError::Authentication(
                        "SSB credentials not configured - run plur-setup or plur-creds set ssb".to_string()
                    ).into()
                } else {
                    e
                }
            })?;
        
        // Validate keypair
        keypair.validate()
            .map_err(|e| -> crate::error::PlurcastError {
                PlatformError::Authentication(
                    format!("Invalid SSB keypair - check credential format: {}", e)
                ).into()
            })?;
        
        tracing::info!(
            "Loaded SSB keypair for account '{}' with feed ID: {}",
            account,
            keypair.id
        );
        
        // Store keypair
        self.keypair = Some(keypair);
        
        // Mark as initialized
        self.initialized = true;
        
        tracing::info!(
            "SSB platform initialized successfully with feed database at {}",
            self.feed_path.display()
        );
        
        Ok(())
    }
    
    /// Get the feed ID (public key) if initialized
    ///
    /// # Returns
    ///
    /// The feed ID (e.g., "@<base64-pubkey>.ed25519") if initialized, None otherwise
    pub fn feed_id(&self) -> Option<&str> {
        self.keypair.as_ref().map(|kp| kp.id.as_str())
    }
    
    /// Check if the platform is initialized
    ///
    /// # Returns
    ///
    /// `true` if the platform has been initialized with credentials, `false` otherwise
    pub fn is_initialized(&self) -> bool {
        self.initialized
    }
    
    /// Create the feed database directory if it doesn't exist
    ///
    /// Creates the directory specified in the configuration's feed_path,
    /// setting appropriate permissions (700 on Unix systems for security).
    ///
    /// # Returns
    ///
    /// `Ok(())` if the directory exists or was created successfully
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - Directory creation fails due to permissions
    /// - Path is invalid or inaccessible
    /// - Permission setting fails (Unix only)
    ///
    /// # Requirements
    ///
    /// - 2.6: Create feed database directory if it doesn't exist
    /// - 2.7: Set appropriate permissions (700) on directory
    /// - 4.1: Check if feed_path exists, create if not
    /// - 4.3: Handle filesystem errors gracefully
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::SSBPlatform;
    /// use libplurcast::config::SSBConfig;
    ///
    /// # fn example() -> libplurcast::error::Result<()> {
    /// let config = SSBConfig {
    ///     enabled: true,
    ///     feed_path: "~/.plurcast-ssb".to_string(),
    ///     pubs: vec![],
    /// };
    ///
    /// let platform = SSBPlatform::new(&config);
    /// platform.create_feed_directory()?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn create_feed_directory(&self) -> Result<()> {
        // Check if directory already exists
        if self.feed_path.exists() {
            // Verify it's actually a directory
            if !self.feed_path.is_dir() {
                return Err(PlatformError::Authentication(
                    format!(
                        "Feed path exists but is not a directory: {}",
                        self.feed_path.display()
                    )
                ).into());
            }
            
            tracing::debug!("Feed database directory already exists: {}", self.feed_path.display());
            return Ok(());
        }
        
        // Create directory with all parent directories
        std::fs::create_dir_all(&self.feed_path)
            .map_err(|e| PlatformError::Authentication(
                format!(
                    "Failed to open SSB feed database at {}: {}",
                    self.feed_path.display(),
                    e
                )
            ))?;
        
        // Set permissions to 700 (owner read/write/execute only) on Unix
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let perms = std::fs::Permissions::from_mode(0o700);
            std::fs::set_permissions(&self.feed_path, perms)
                .map_err(|e| PlatformError::Authentication(
                    format!(
                        "Failed to set permissions on feed database directory {}: {}",
                        self.feed_path.display(),
                        e
                    )
                ))?;
            
            tracing::debug!(
                "Created feed database directory with permissions 700: {}",
                self.feed_path.display()
            );
        }
        
        #[cfg(not(unix))]
        {
            tracing::debug!(
                "Created feed database directory: {}",
                self.feed_path.display()
            );
        }
        
        Ok(())
    }
    
    /// Store SSB keypair in credential manager
    ///
    /// Stores the keypair as a JSON string in the credential manager under
    /// the service "plurcast.ssb" with key "keypair".
    ///
    /// # Arguments
    ///
    /// * `credentials` - Credential manager instance
    /// * `keypair` - SSB keypair to store
    /// * `account` - Account name (e.g., "default", "test-account")
    ///
    /// # Returns
    ///
    /// `Ok(())` if the keypair was stored successfully
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - Keypair serialization fails
    /// - Credential storage fails
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::{SSBPlatform, SSBKeypair};
    /// use libplurcast::credentials::{CredentialManager, CredentialConfig};
    ///
    /// # fn example() -> libplurcast::error::Result<()> {
    /// let config = CredentialConfig::default();
    /// let credentials = CredentialManager::new(config)?;
    ///
    /// let keypair = SSBKeypair::generate();
    /// SSBPlatform::store_keypair(&credentials, &keypair, "default")?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn store_keypair(
        credentials: &crate::credentials::CredentialManager,
        keypair: &SSBKeypair,
        account: &str,
    ) -> Result<()> {
        let json = keypair.to_json()?;
        credentials.store_account("plurcast.ssb", "keypair", account, &json)?;
        tracing::debug!("Stored SSB keypair for account '{}' in credential manager", account);
        Ok(())
    }
    
    /// Retrieve SSB keypair from credential manager
    ///
    /// Retrieves and parses the keypair from the credential manager.
    ///
    /// # Arguments
    ///
    /// * `credentials` - Credential manager instance
    /// * `account` - Account name (e.g., "default", "test-account")
    ///
    /// # Returns
    ///
    /// The parsed and validated SSB keypair
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - Credential not found
    /// - JSON parsing fails
    /// - Keypair validation fails
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::SSBPlatform;
    /// use libplurcast::credentials::{CredentialManager, CredentialConfig};
    ///
    /// # fn example() -> libplurcast::error::Result<()> {
    /// let config = CredentialConfig::default();
    /// let credentials = CredentialManager::new(config)?;
    ///
    /// let keypair = SSBPlatform::retrieve_keypair(&credentials, "default")?;
    /// println!("Feed ID: {}", keypair.id);
    /// # Ok(())
    /// # }
    /// ```
    pub fn retrieve_keypair(
        credentials: &crate::credentials::CredentialManager,
        account: &str,
    ) -> Result<SSBKeypair> {
        let json = credentials.retrieve_account("plurcast.ssb", "keypair", account)?;
        let keypair = SSBKeypair::from_json(&json)?;
        tracing::debug!("Retrieved SSB keypair for account '{}' from credential manager", account);
        Ok(keypair)
    }
    
    /// Check if SSB keypair exists in credential manager
    ///
    /// # Arguments
    ///
    /// * `credentials` - Credential manager instance
    /// * `account` - Account name (e.g., "default", "test-account")
    ///
    /// # Returns
    ///
    /// `true` if the keypair exists, `false` otherwise
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::SSBPlatform;
    /// use libplurcast::credentials::{CredentialManager, CredentialConfig};
    ///
    /// # fn example() -> libplurcast::error::Result<()> {
    /// let config = CredentialConfig::default();
    /// let credentials = CredentialManager::new(config)?;
    ///
    /// if SSBPlatform::has_keypair(&credentials, "default")? {
    ///     println!("SSB keypair is configured");
    /// }
    /// # Ok(())
    /// # }
    /// ```
    pub fn has_keypair(
        credentials: &crate::credentials::CredentialManager,
        account: &str,
    ) -> Result<bool> {
        credentials.exists_account("plurcast.ssb", "keypair", account)
    }
    
    /// Import SSB keypair from standard ~/.ssb/secret file
    ///
    /// Reads and parses the keypair from the standard SSB secret file location.
    /// The file should be in JSON format with the standard SSB secret structure.
    ///
    /// # Standard SSB Secret File Format
    ///
    /// The file at `~/.ssb/secret` should contain:
    /// ```json
    /// {
    ///   "curve": "ed25519",
    ///   "public": "<base64>.ed25519",
    ///   "private": "<base64>.ed25519",
    ///   "id": "@<base64>.ed25519"
    /// }
    /// ```
    ///
    /// The file may also contain JavaScript-style comments which will be stripped
    /// before parsing.
    ///
    /// # Returns
    ///
    /// The parsed and validated SSB keypair
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - File not found at ~/.ssb/secret
    /// - File cannot be read
    /// - JSON parsing fails
    /// - Keypair validation fails
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::SSBPlatform;
    ///
    /// # fn example() -> libplurcast::error::Result<()> {
    /// let keypair = SSBPlatform::import_from_ssb_secret()?;
    /// println!("Imported keypair with feed ID: {}", keypair.id);
    /// # Ok(())
    /// # }
    /// ```
    pub fn import_from_ssb_secret() -> Result<SSBKeypair> {
        // Get home directory
        let home = dirs::home_dir()
            .ok_or_else(|| PlatformError::Authentication(
                "Could not determine home directory".to_string()
            ))?;
        
        // Build path to ~/.ssb/secret
        let secret_path = home.join(".ssb").join("secret");
        
        // Check if file exists
        if !secret_path.exists() {
            return Err(PlatformError::Authentication(
                format!("SSB secret file not found at {}", secret_path.display())
            ).into());
        }
        
        // Read file contents
        let contents = std::fs::read_to_string(&secret_path)
            .map_err(|e| PlatformError::Authentication(
                format!("Failed to read SSB secret file: {}", e)
            ))?;
        
        // Strip JavaScript-style comments (SSB secret files often have comments)
        let json = Self::strip_js_comments(&contents);
        
        // Parse and validate keypair
        let keypair = SSBKeypair::from_json(&json)?;
        
        tracing::info!("Imported SSB keypair from {}", secret_path.display());
        Ok(keypair)
    }
    
    /// Import SSB keypair from a custom file path
    ///
    /// Similar to `import_from_ssb_secret()` but allows specifying a custom file path.
    ///
    /// # Arguments
    ///
    /// * `path` - Path to the SSB secret file
    ///
    /// # Returns
    ///
    /// The parsed and validated SSB keypair
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - File not found
    /// - File cannot be read
    /// - JSON parsing fails
    /// - Keypair validation fails
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::SSBPlatform;
    /// use std::path::PathBuf;
    ///
    /// # fn example() -> libplurcast::error::Result<()> {
    /// let path = PathBuf::from("/path/to/secret");
    /// let keypair = SSBPlatform::import_from_file(&path)?;
    /// println!("Imported keypair with feed ID: {}", keypair.id);
    /// # Ok(())
    /// # }
    /// ```
    pub fn import_from_file(path: &std::path::Path) -> Result<SSBKeypair> {
        // Check if file exists
        if !path.exists() {
            return Err(PlatformError::Authentication(
                format!("SSB secret file not found at {}", path.display())
            ).into());
        }
        
        // Read file contents
        let contents = std::fs::read_to_string(path)
            .map_err(|e| PlatformError::Authentication(
                format!("Failed to read SSB secret file: {}", e)
            ))?;
        
        // Strip JavaScript-style comments
        let json = Self::strip_js_comments(&contents);
        
        // Parse and validate keypair
        let keypair = SSBKeypair::from_json(&json)?;
        
        tracing::info!("Imported SSB keypair from {}", path.display());
        Ok(keypair)
    }
    
    /// Query the current feed state (sequence number and previous message hash)
    ///
    /// Reads the feed database to determine the next sequence number and
    /// the hash of the most recent message.
    ///
    /// # Returns
    ///
    /// A tuple of (next_sequence, previous_hash)
    /// - For the first message: (1, None)
    /// - For subsequent messages: (n+1, Some(hash))
    ///
    /// # Errors
    ///
    /// Returns an error if the feed database cannot be read
    ///
    /// # Requirements
    ///
    /// - 5.9: Query feed for previous message hash
    /// - 5.10: Set previous to null for first message
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::SSBPlatform;
    /// use libplurcast::config::SSBConfig;
    ///
    /// # async fn example() -> libplurcast::error::Result<()> {
    /// let config = SSBConfig {
    ///     enabled: true,
    ///     feed_path: "~/.plurcast-ssb".to_string(),
    ///     pubs: vec![],
    /// };
    ///
    /// let platform = SSBPlatform::new(&config);
    /// let (sequence, previous) = platform.query_feed_state().await?;
    /// println!("Next sequence: {}, Previous: {:?}", sequence, previous);
    /// # Ok(())
    /// # }
    /// ```
    async fn query_feed_state(&self) -> Result<(u64, Option<String>)> {
        // Check if feed database directory exists
        if !self.feed_path.exists() {
            // No feed database yet, this is the first message
            tracing::debug!("Feed database does not exist, starting with sequence 1");
            return Ok((1, None));
        }
        
        // Check for feed.json file that tracks the latest message
        let feed_state_file = self.feed_path.join("feed.json");
        
        if !feed_state_file.exists() {
            // No state file yet, this is the first message
            tracing::debug!("Feed state file does not exist, starting with sequence 1");
            return Ok((1, None));
        }
        
        // Read and parse feed state
        let state_json = std::fs::read_to_string(&feed_state_file)
            .map_err(|e| PlatformError::Authentication(
                format!("Failed to read feed state file: {}", e)
            ))?;
        
        let state: serde_json::Value = serde_json::from_str(&state_json)
            .map_err(|e| PlatformError::Authentication(
                format!("Failed to parse feed state file: {}", e)
            ))?;
        
        // Extract sequence and previous hash
        let sequence = state.get("sequence")
            .and_then(|v| v.as_u64())
            .ok_or_else(|| PlatformError::Authentication(
                "Invalid feed state: missing sequence".to_string()
            ))?;
        
        let previous = state.get("previous")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());
        
        // Next sequence is current + 1
        let next_sequence = sequence + 1;
        
        tracing::debug!(
            "Feed state: current sequence {}, next sequence {}, previous: {:?}",
            sequence,
            next_sequence,
            previous.as_ref().map(|s| &s[..20]) // Log first 20 chars
        );
        
        Ok((next_sequence, previous))
    }
    
    /// Append a signed message to the feed database
    ///
    /// Writes the message to the feed database and updates the feed state.
    /// The message must be signed before calling this method.
    ///
    /// # Arguments
    ///
    /// * `message` - Signed SSB message to append
    ///
    /// # Returns
    ///
    /// The message ID in format "ssb:%<hash>"
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - Message is not signed
    /// - Feed database cannot be written
    /// - Message hash calculation fails
    ///
    /// # Requirements
    ///
    /// - 1.4: Append message to local SSB feed database
    /// - 1.5: Return SSB message identifier in format "ssb:%<hash>"
    /// - 6.2: Use kuska-ssb to append signed message to feed
    /// - 6.2: Extract message ID from append result
    /// - 6.2: Format message ID as "ssb:%<hash>"
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::{SSBPlatform, SSBMessage, SSBKeypair};
    /// use libplurcast::config::SSBConfig;
    ///
    /// # async fn example() -> libplurcast::error::Result<()> {
    /// let config = SSBConfig {
    ///     enabled: true,
    ///     feed_path: "~/.plurcast-ssb".to_string(),
    ///     pubs: vec![],
    /// };
    ///
    /// let keypair = SSBKeypair::generate();
    /// let mut message = SSBMessage::new_post(&keypair.id, 1, None, "Hello SSB!");
    /// message.sign(&keypair)?;
    ///
    /// let platform = SSBPlatform::new(&config);
    /// let message_id = platform.append_to_feed(&message).await?;
    /// println!("Message ID: {}", message_id);
    /// # Ok(())
    /// # }
    /// ```
    async fn append_to_feed(&self, message: &SSBMessage) -> Result<String> {
        // Verify message is signed
        if message.signature.is_none() {
            return Err(PlatformError::Validation(
                "Cannot append unsigned message to feed".to_string()
            ).into());
        }
        
        // Calculate message hash
        let hash = message.calculate_hash()
            .map_err(|e| PlatformError::Authentication(
                format!("Failed to calculate message hash: {}", e)
            ))?;
        
        // Create feed database directory if it doesn't exist
        self.create_feed_directory()?;
        
        // Create messages directory
        let messages_dir = self.feed_path.join("messages");
        if !messages_dir.exists() {
            std::fs::create_dir_all(&messages_dir)
                .map_err(|e| PlatformError::Authentication(
                    format!("Failed to create messages directory: {}", e)
                ))?;
        }
        
        // Write message to file (using sequence number as filename)
        let message_file = messages_dir.join(format!("{:010}.json", message.sequence));
        let message_json = serde_json::to_string_pretty(message)
            .map_err(|e| PlatformError::Authentication(
                format!("Failed to serialize message: {}", e)
            ))?;
        
        std::fs::write(&message_file, message_json)
            .map_err(|e| PlatformError::Authentication(
                format!("Failed to write message to feed: {}", e)
            ))?;
        
        // Update feed state file
        let feed_state_file = self.feed_path.join("feed.json");
        let state = serde_json::json!({
            "sequence": message.sequence,
            "previous": hash,
            "author": message.author,
            "updated_at": chrono::Utc::now().to_rfc3339(),
        });
        
        let state_json = serde_json::to_string_pretty(&state)
            .map_err(|e| PlatformError::Authentication(
                format!("Failed to serialize feed state: {}", e)
            ))?;
        
        std::fs::write(&feed_state_file, state_json)
            .map_err(|e| PlatformError::Authentication(
                format!("Failed to write feed state: {}", e)
            ))?;
        
        tracing::debug!(
            "Appended message to feed: sequence {}, hash {}",
            message.sequence,
            &hash[..20] // Log first 20 chars
        );
        
        // Format message ID as "ssb:%<hash>" (without the .sha256 suffix)
        let message_id = if hash.ends_with(".sha256") {
            format!("ssb:{}", &hash[..hash.len() - 7]) // Remove .sha256 suffix
        } else {
            format!("ssb:{}", hash)
        };
        
        Ok(message_id)
    }
    
    /// Connect to all configured pub servers
    ///
    /// Attempts to establish connections to all pubs in the configuration.
    /// Failures are logged but don't prevent other connections from being attempted.
    ///
    /// # Returns
    ///
    /// Number of successful connections
    ///
    /// # Requirements
    ///
    /// - 7.2: Establish TCP connection to pub
    /// - 7.2: Handle connection failures gracefully
    /// - 7.3: Handle multiple pub connections concurrently
    /// - 15.8: Emit warning when no pubs are configured
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::SSBPlatform;
    /// use libplurcast::config::SSBConfig;
    ///
    /// # async fn example() -> libplurcast::error::Result<()> {
    /// let config = SSBConfig {
    ///     enabled: true,
    ///     feed_path: "~/.plurcast-ssb".to_string(),
    ///     pubs: vec!["net:hermies.club:8008~shs:key".to_string()],
    /// };
    ///
    /// let mut platform = SSBPlatform::new(&config);
    /// let connected = platform.connect_to_pubs().await?;
    /// println!("Connected to {} pubs", connected);
    /// # Ok(())
    /// # }
    /// ```
    pub async fn connect_to_pubs(&mut self) -> Result<usize> {
        // Check if we have a keypair
        let keypair = self.keypair.as_ref()
            .ok_or_else(|| PlatformError::Authentication(
                "SSB keypair not loaded - call initialize_with_credentials first".to_string()
            ))?;
        
        // Check if any pubs are configured
        if self.pub_connections.is_empty() {
            tracing::warn!(
                "No pub servers configured - posts will be local-only. \
                Add pub servers to config.toml to replicate to the SSB network."
            );
            return Ok(0);
        }
        
        tracing::info!(
            "Connecting to {} pub server(s)...",
            self.pub_connections.len()
        );
        
        // Connect to all pubs concurrently
        let mut successful = 0;
        let mut failed = 0;
        
        for connection in &mut self.pub_connections {
            match connection.connect(keypair).await {
                Ok(()) => {
                    successful += 1;
                    tracing::info!(
                        "Connected to pub {} successfully",
                        connection.address.socket_addr()
                    );
                }
                Err(e) => {
                    failed += 1;
                    tracing::warn!(
                        "Failed to connect to pub {}: {}",
                        connection.address.socket_addr(),
                        e
                    );
                }
            }
        }
        
        if successful > 0 {
            tracing::info!(
                "Connected to {}/{} pub server(s)",
                successful,
                self.pub_connections.len()
            );
        } else {
            tracing::warn!(
                "Failed to connect to any pub servers ({} failed). \
                Posts will be local-only.",
                failed
            );
        }
        
        Ok(successful)
    }
    
    /// Get the list of connected pubs
    ///
    /// # Returns
    ///
    /// Vector of socket addresses for connected pubs
    pub fn connected_pubs(&self) -> Vec<String> {
        self.pub_connections.iter()
            .filter(|conn| conn.is_connected())
            .map(|conn| conn.address.socket_addr())
            .collect()
    }
    
    /// Disconnect from all pub servers
    ///
    /// Closes all active pub connections.
    pub fn disconnect_from_pubs(&mut self) {
        for connection in &mut self.pub_connections {
            connection.disconnect();
        }
        
        tracing::debug!("Disconnected from all pub servers");
    }
    
    /// Maintain pub connections
    ///
    /// Checks all pub connections and attempts to reconnect any that are disconnected.
    /// Uses exponential backoff to avoid overwhelming servers with connection attempts.
    ///
    /// # Returns
    ///
    /// Number of active connections after maintenance
    ///
    /// # Requirements
    ///
    /// - 7.3: Keep connections alive for replication
    /// - 7.3: Reconnect on disconnection
    /// - 7.3: Handle multiple pub connections concurrently
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::SSBPlatform;
    /// use libplurcast::config::SSBConfig;
    ///
    /// # async fn example() -> libplurcast::error::Result<()> {
    /// let config = SSBConfig {
    ///     enabled: true,
    ///     feed_path: "~/.plurcast-ssb".to_string(),
    ///     pubs: vec!["net:hermies.club:8008~shs:key".to_string()],
    /// };
    ///
    /// let mut platform = SSBPlatform::new(&config);
    /// let active = platform.maintain_pub_connections().await?;
    /// println!("Active connections: {}", active);
    /// # Ok(())
    /// # }
    /// ```
    pub async fn maintain_pub_connections(&mut self) -> Result<usize> {
        // Check if we have a keypair
        let keypair = self.keypair.as_ref()
            .ok_or_else(|| PlatformError::Authentication(
                "SSB keypair not loaded - call initialize_with_credentials first".to_string()
            ))?;
        
        // Try to reconnect any disconnected pubs that are ready for retry
        for connection in &mut self.pub_connections {
            if connection.should_reconnect() {
                tracing::debug!(
                    "Attempting to reconnect to pub {} (attempt {})",
                    connection.address.socket_addr(),
                    connection.attempts + 1
                );
                
                // Attempt reconnection (errors are logged but don't fail the operation)
                let _ = connection.connect(keypair).await;
            }
        }
        
        // Count active connections
        let active = self.pub_connections.iter()
            .filter(|conn| conn.is_connected())
            .count();
        
        tracing::debug!(
            "Pub connection maintenance complete: {}/{} active",
            active,
            self.pub_connections.len()
        );
        
        Ok(active)
    }
    
    /// Strip JavaScript-style comments from JSON
    ///
    /// SSB secret files often contain JavaScript-style comments (// and /* */)
    /// which are not valid JSON. This function removes them before parsing.
    ///
    /// # Arguments
    ///
    /// * `input` - Input string potentially containing comments
    ///
    /// # Returns
    ///
    /// String with comments removed
    fn strip_js_comments(input: &str) -> String {
        let mut result = String::new();
        let mut chars = input.chars().peekable();
        let mut in_string = false;
        let mut escape_next = false;
        
        while let Some(c) = chars.next() {
            if escape_next {
                result.push(c);
                escape_next = false;
                continue;
            }
            
            if c == '\\' && in_string {
                result.push(c);
                escape_next = true;
                continue;
            }
            
            if c == '"' {
                in_string = !in_string;
                result.push(c);
                continue;
            }
            
            if !in_string && c == '/' {
                if let Some(&next_c) = chars.peek() {
                    if next_c == '/' {
                        // Single-line comment - skip until end of line
                        chars.next(); // consume the second /
                        while let Some(c) = chars.next() {
                            if c == '\n' {
                                result.push(c); // keep the newline
                                break;
                            }
                        }
                        continue;
                    } else if next_c == '*' {
                        // Multi-line comment - skip until */
                        chars.next(); // consume the *
                        let mut prev = ' ';
                        while let Some(c) = chars.next() {
                            if prev == '*' && c == '/' {
                                break;
                            }
                            prev = c;
                        }
                        continue;
                    }
                }
            }
            
            result.push(c);
        }
        
        result
    }
    
    // ============================================================================
    // Task 8.1: Push replication (send our messages)
    // Requirements: 7.4, 7.5
    // ============================================================================
    
    /// Push replicate a message to connected pub servers
    ///
    /// Sends a newly posted message to all connected pub servers for replication.
    /// This operation is non-blocking and failures are logged but don't fail the post.
    ///
    /// # Arguments
    ///
    /// * `message` - The signed SSB message to replicate
    ///
    /// # Returns
    ///
    /// Number of pubs that successfully received the message
    ///
    /// # Requirements
    ///
    /// - 7.4: After posting, trigger replication to pubs
    /// - 7.5: Send new messages to connected pubs
    /// - 7.5: Use kuska-ssb's replication protocol
    /// - 7.5: Don't block on replication completion
    /// - 15.2: Initiate replication with configured pub servers
    /// - 15.5: Push the new message to the pub server
    /// - 15.6: Log the successful replication
    /// - 15.7: Log the error but not fail the post operation
    /// - 15.9: Log replication progress and connection details
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::{SSBPlatform, SSBMessage, SSBKeypair};
    /// use libplurcast::config::SSBConfig;
    ///
    /// # async fn example() -> libplurcast::error::Result<()> {
    /// let config = SSBConfig {
    ///     enabled: true,
    ///     feed_path: "~/.plurcast-ssb".to_string(),
    ///     pubs: vec!["net:hermies.club:8008~shs:key".to_string()],
    /// };
    ///
    /// let keypair = SSBKeypair::generate();
    /// let mut message = SSBMessage::new_post(&keypair.id, 1, None, "Hello SSB!");
    /// message.sign(&keypair)?;
    ///
    /// let mut platform = SSBPlatform::new(&config);
    /// let replicated = platform.push_replicate(&message).await?;
    /// println!("Replicated to {} pubs", replicated);
    /// # Ok(())
    /// # }
    /// ```
    pub async fn push_replicate(&mut self, message: &SSBMessage) -> Result<usize> {
        // Check if any pubs are connected
        let connected_count = self.pub_connections.iter()
            .filter(|conn| conn.is_connected())
            .count();
        
        if connected_count == 0 {
            tracing::debug!(
                "No connected pubs for replication (sequence {})",
                message.sequence
            );
            return Ok(0);
        }
        
        tracing::debug!(
            "Starting push replication of message (sequence {}) to {} pub(s)",
            message.sequence,
            connected_count
        );
        
        let mut successful = 0;
        let mut failed = 0;
        
        // Serialize message for transmission
        let message_json = serde_json::to_string(message)
            .map_err(|e| PlatformError::Authentication(
                format!("Failed to serialize message for replication: {}", e)
            ))?;
        
        // Push to each connected pub
        for connection in &mut self.pub_connections {
            if !connection.is_connected() {
                continue;
            }
            
            tracing::debug!(
                "Pushing message (sequence {}) to pub {}",
                message.sequence,
                connection.address.socket_addr()
            );
            
            // TODO: Implement actual SSB replication protocol using kuska-ssb
            // For now, we'll simulate the push operation
            // Full implementation will use kuska-ssb's RPC protocol to send messages
            
            // Simulate push (in real implementation, this would use kuska-ssb)
            match Self::simulate_push_to_pub(connection, &message_json).await {
                Ok(()) => {
                    successful += 1;
                    connection.reset_attempts(); // Reset backoff on success
                    
                    tracing::info!(
                        "Successfully replicated message (sequence {}) to pub {}",
                        message.sequence,
                        connection.address.socket_addr()
                    );
                }
                Err(e) => {
                    failed += 1;
                    connection.last_error = Some(e.to_string());
                    
                    tracing::warn!(
                        "Failed to replicate message (sequence {}) to pub {}: {}",
                        message.sequence,
                        connection.address.socket_addr(),
                        e
                    );
                }
            }
        }
        
        if successful > 0 {
            tracing::info!(
                "Push replication complete: {}/{} pubs successful (sequence {})",
                successful,
                connected_count,
                message.sequence
            );
        } else if failed > 0 {
            tracing::warn!(
                "Push replication failed for all {} pubs (sequence {})",
                failed,
                message.sequence
            );
        }
        
        Ok(successful)
    }
    
    /// Simulate pushing a message to a pub server
    ///
    /// This is a placeholder for the actual kuska-ssb replication protocol.
    /// In the full implementation, this will use kuska-ssb's RPC protocol.
    ///
    /// # Arguments
    ///
    /// * `connection` - Pub connection to push to
    /// * `message_json` - Serialized message JSON
    ///
    /// # Returns
    ///
    /// `Ok(())` if push succeeds
    async fn simulate_push_to_pub(
        _connection: &PubConnection,
        _message_json: &str,
    ) -> Result<()> {
        // TODO: Replace with actual kuska-ssb replication protocol
        // This would involve:
        // 1. Establishing RPC connection over the TCP stream
        // 2. Calling the appropriate SSB RPC method (e.g., "createHistoryStream")
        // 3. Sending the message
        // 4. Waiting for acknowledgment
        
        // For now, just simulate success
        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
        Ok(())
    }
    
    // ============================================================================
    // Task 8.2: Pull replication (receive messages)
    // Requirements: 9.2
    // ============================================================================
    
    /// Pull replicate messages from connected pub servers
    ///
    /// Requests and receives messages from connected pub servers.
    /// For now, this only pulls our own feed. In the future, it will pull
    /// feeds from followed users.
    ///
    /// # Returns
    ///
    /// Number of messages received and stored
    ///
    /// # Requirements
    ///
    /// - 9.2: Request feeds from followed users (future: for now, just our own)
    /// - 9.2: Receive and validate messages from pubs
    /// - 9.2: Store received messages in local database
    /// - 17.2: Connect to configured pubs and pull new messages
    /// - 17.3: Validate signatures and append to local feed database
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::SSBPlatform;
    /// use libplurcast::config::SSBConfig;
    ///
    /// # async fn example() -> libplurcast::error::Result<()> {
    /// let config = SSBConfig {
    ///     enabled: true,
    ///     feed_path: "~/.plurcast-ssb".to_string(),
    ///     pubs: vec!["net:hermies.club:8008~shs:key".to_string()],
    /// };
    ///
    /// let mut platform = SSBPlatform::new(&config);
    /// let received = platform.pull_replicate().await?;
    /// println!("Received {} messages", received);
    /// # Ok(())
    /// # }
    /// ```
    pub async fn pull_replicate(&mut self) -> Result<usize> {
        // Check if we have a keypair
        let keypair = self.keypair.as_ref()
            .ok_or_else(|| PlatformError::Authentication(
                "SSB keypair not loaded - call initialize_with_credentials first".to_string()
            ))?;
        
        // Check if any pubs are connected
        let connected_count = self.pub_connections.iter()
            .filter(|conn| conn.is_connected())
            .count();
        
        if connected_count == 0 {
            tracing::debug!("No connected pubs for pull replication");
            return Ok(0);
        }
        
        tracing::debug!(
            "Starting pull replication from {} pub(s)",
            connected_count
        );
        
        let mut total_received = 0;
        
        // Pull from each connected pub
        for connection in &mut self.pub_connections {
            if !connection.is_connected() {
                continue;
            }
            
            tracing::debug!(
                "Pulling messages from pub {}",
                connection.address.socket_addr()
            );
            
            // TODO: Implement actual SSB replication protocol using kuska-ssb
            // For now, we'll simulate the pull operation
            // Full implementation will use kuska-ssb's RPC protocol to request messages
            
            match Self::simulate_pull_from_pub(connection, &keypair.id).await {
                Ok(messages) => {
                    tracing::debug!(
                        "Received {} messages from pub {}",
                        messages.len(),
                        connection.address.socket_addr()
                    );
                    
                    // Validate and store each message
                    for message in messages {
                        match self.validate_and_store_message(&message, keypair).await {
                            Ok(()) => {
                                total_received += 1;
                                tracing::debug!(
                                    "Stored message (sequence {}) from pub {}",
                                    message.sequence,
                                    connection.address.socket_addr()
                                );
                            }
                            Err(e) => {
                                tracing::warn!(
                                    "Failed to validate/store message from pub {}: {}",
                                    connection.address.socket_addr(),
                                    e
                                );
                            }
                        }
                    }
                    
                    connection.reset_attempts(); // Reset backoff on success
                }
                Err(e) => {
                    connection.last_error = Some(e.to_string());
                    
                    tracing::warn!(
                        "Failed to pull messages from pub {}: {}",
                        connection.address.socket_addr(),
                        e
                    );
                }
            }
        }
        
        if total_received > 0 {
            tracing::info!(
                "Pull replication complete: received {} messages from {} pub(s)",
                total_received,
                connected_count
            );
        } else {
            tracing::debug!(
                "Pull replication complete: no new messages from {} pub(s)",
                connected_count
            );
        }
        
        Ok(total_received)
    }
    
    /// Simulate pulling messages from a pub server
    ///
    /// This is a placeholder for the actual kuska-ssb replication protocol.
    /// In the full implementation, this will use kuska-ssb's RPC protocol.
    ///
    /// # Arguments
    ///
    /// * `connection` - Pub connection to pull from
    /// * `feed_id` - Feed ID to request messages for
    ///
    /// # Returns
    ///
    /// Vector of received messages
    async fn simulate_pull_from_pub(
        _connection: &PubConnection,
        _feed_id: &str,
    ) -> Result<Vec<SSBMessage>> {
        // TODO: Replace with actual kuska-ssb replication protocol
        // This would involve:
        // 1. Establishing RPC connection over the TCP stream
        // 2. Calling "createHistoryStream" RPC method with our feed ID
        // 3. Receiving messages from the stream
        // 4. Parsing and validating each message
        
        // For now, return empty vector (no new messages)
        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
        Ok(vec![])
    }
    
    /// Validate and store a received message
    ///
    /// Validates the message signature and stores it in the local feed database
    /// if it's valid and not a duplicate.
    ///
    /// # Arguments
    ///
    /// * `message` - Message to validate and store
    /// * `keypair` - Keypair for signature verification
    ///
    /// # Returns
    ///
    /// `Ok(())` if message is valid and stored
    ///
    /// # Requirements
    ///
    /// - 9.2: Validate messages from pubs
    /// - 9.2: Store received messages in local database
    /// - 17.3: Validate signatures and append to local feed database
    async fn validate_and_store_message(
        &self,
        message: &SSBMessage,
        keypair: &SSBKeypair,
    ) -> Result<()> {
        // Validate message structure
        message.validate()?;
        
        // Verify signature
        message.verify_signature(keypair)?;
        
        // Check if message already exists (avoid duplicates)
        let messages_dir = self.feed_path.join("messages");
        let message_file = messages_dir.join(format!("{:010}.json", message.sequence));
        
        if message_file.exists() {
            tracing::debug!(
                "Message (sequence {}) already exists, skipping",
                message.sequence
            );
            return Ok(());
        }
        
        // Store the message
        if !messages_dir.exists() {
            std::fs::create_dir_all(&messages_dir)
                .map_err(|e| PlatformError::Authentication(
                    format!("Failed to create messages directory: {}", e)
                ))?;
        }
        
        let message_json = serde_json::to_string_pretty(message)
            .map_err(|e| PlatformError::Authentication(
                format!("Failed to serialize message: {}", e)
            ))?;
        
        std::fs::write(&message_file, message_json)
            .map_err(|e| PlatformError::Authentication(
                format!("Failed to write message to feed: {}", e)
            ))?;
        
        tracing::debug!(
            "Stored received message (sequence {}) to local feed",
            message.sequence
        );
        
        Ok(())
    }
    
    // ============================================================================
    // Task 8.3: Background replication process
    // Requirements: 7.4
    // ============================================================================
    
    /// Run background replication process
    ///
    /// Performs both push and pull replication in the background.
    /// This should be called after posting or periodically to keep the feed in sync.
    ///
    /// # Returns
    ///
    /// Tuple of (messages_pushed, messages_pulled)
    ///
    /// # Requirements
    ///
    /// - 7.4: Spawn background task for periodic sync
    /// - 7.4: Sync on startup and every N minutes
    /// - 7.4: Handle sync errors without crashing
    /// - 17.1: Spawn a background replication task
    /// - 17.4: Exit gracefully when background task completes
    /// - 17.5: Log errors but continue operation
    /// - 17.7: Log received message counts and sync duration
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::SSBPlatform;
    /// use libplurcast::config::SSBConfig;
    ///
    /// # async fn example() -> libplurcast::error::Result<()> {
    /// let config = SSBConfig {
    ///     enabled: true,
    ///     feed_path: "~/.plurcast-ssb".to_string(),
    ///     pubs: vec!["net:hermies.club:8008~shs:key".to_string()],
    /// };
    ///
    /// let mut platform = SSBPlatform::new(&config);
    /// let (pushed, pulled) = platform.background_replicate().await?;
    /// println!("Pushed: {}, Pulled: {}", pushed, pulled);
    /// # Ok(())
    /// # }
    /// ```
    pub async fn background_replicate(&mut self) -> Result<(usize, usize)> {
        let start_time = std::time::Instant::now();
        
        tracing::debug!("Starting background replication");
        
        // First, maintain pub connections (reconnect if needed)
        let active_connections = self.maintain_pub_connections().await?;
        
        if active_connections == 0 {
            tracing::debug!("No active pub connections for background replication");
            return Ok((0, 0));
        }
        
        // Pull new messages from pubs
        let pulled = match self.pull_replicate().await {
            Ok(count) => count,
            Err(e) => {
                tracing::warn!("Pull replication failed: {}", e);
                0
            }
        };
        
        // Note: Push replication is typically done immediately after posting,
        // not in background sync. But we could add it here if needed.
        let pushed = 0;
        
        let duration = start_time.elapsed();
        
        tracing::info!(
            "Background replication complete: pushed {}, pulled {} messages in {:.2}s",
            pushed,
            pulled,
            duration.as_secs_f64()
        );
        
        Ok((pushed, pulled))
    }
    
    /// Spawn a background replication task
    ///
    /// Spawns a tokio task that runs background replication periodically.
    /// The task will continue running until the platform is dropped or
    /// the task is explicitly cancelled.
    ///
    /// # Arguments
    ///
    /// * `interval_secs` - Interval between replication runs in seconds
    ///
    /// # Returns
    ///
    /// A `JoinHandle` that can be used to wait for or cancel the task
    ///
    /// # Requirements
    ///
    /// - 7.4: Spawn background task for periodic sync
    /// - 7.4: Sync on startup and every N minutes
    /// - 7.4: Handle sync errors without crashing
    /// - 17.1: Spawn a background replication task
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use libplurcast::platforms::ssb::SSBPlatform;
    /// use libplurcast::config::SSBConfig;
    ///
    /// # async fn example() -> libplurcast::error::Result<()> {
    /// let config = SSBConfig {
    ///     enabled: true,
    ///     feed_path: "~/.plurcast-ssb".to_string(),
    ///     pubs: vec!["net:hermies.club:8008~shs:key".to_string()],
    /// };
    ///
    /// let mut platform = SSBPlatform::new(&config);
    /// 
    /// // Spawn background replication task (sync every 5 minutes)
    /// let handle = platform.spawn_background_replication(300);
    ///
    /// // Do other work...
    ///
    /// // Cancel the task when done
    /// handle.abort();
    /// # Ok(())
    /// # }
    /// ```
    pub fn spawn_background_replication(
        &mut self,
        interval_secs: u64,
    ) -> tokio::task::JoinHandle<()> {
        // Clone the necessary data for the background task
        let config = self.config.clone();
        let feed_path = self.feed_path.clone();
        let keypair = self.keypair.clone();
        let pub_connections = self.pub_connections.clone();
        
        tokio::spawn(async move {
            tracing::info!(
                "Background replication task started (interval: {}s)",
                interval_secs
            );
            
            let mut interval = tokio::time::interval(
                tokio::time::Duration::from_secs(interval_secs)
            );
            
            loop {
                interval.tick().await;
                
                tracing::debug!("Background replication tick");
                
                // Create a temporary platform instance for this sync
                let mut platform = SSBPlatform {
                    config: config.clone(),
                    feed_path: feed_path.clone(),
                    keypair: keypair.clone(),
                    initialized: keypair.is_some(),
                    pub_connections: pub_connections.clone(),
                };
                
                // Run background replication
                match platform.background_replicate().await {
                    Ok((pushed, pulled)) => {
                        if pushed > 0 || pulled > 0 {
                            tracing::info!(
                                "Background sync: pushed {}, pulled {} messages",
                                pushed,
                                pulled
                            );
                        }
                    }
                    Err(e) => {
                        tracing::warn!("Background replication error: {}", e);
                        // Continue running despite errors
                    }
                }
            }
        })
    }
}

#[async_trait]
impl Platform for SSBPlatform {
    async fn authenticate(&mut self) -> Result<()> {
        // Check if already initialized
        if self.initialized {
            tracing::debug!("SSB platform already initialized");
            return Ok(());
        }
        
        // Create feed database directory if it doesn't exist
        self.create_feed_directory()?;
        
        // Load keypair from credential manager
        // Note: This requires credential manager to be passed in or accessed globally
        // For now, we'll return an error indicating credentials need to be set up
        // The actual credential loading will be done by the calling code
        
        tracing::info!(
            "SSB platform initialized with feed database at {}",
            self.feed_path.display()
        );
        
        self.initialized = true;
        Ok(())
    }

    async fn post(&self, content: &str) -> Result<String> {
        // Check if platform is initialized
        if !self.initialized {
            return Err(PlatformError::Authentication(
                "SSB platform not initialized - call initialize_with_credentials first".to_string()
            ).into());
        }
        
        // Get keypair
        let keypair = self.keypair.as_ref()
            .ok_or_else(|| PlatformError::Authentication(
                "SSB keypair not loaded".to_string()
            ))?;
        
        // Validate content before creating message
        self.validate_content(content)?;
        
        // Query feed for previous message hash and sequence
        // For now, we'll start with sequence 1 and no previous (first message)
        // TODO: In task 7-8, implement proper feed database querying
        let (sequence, previous) = self.query_feed_state().await?;
        
        // Create SSB message
        let message = SSBMessage::new_post(
            &keypair.id,
            sequence,
            previous,
            content,
        );
        
        // Sign the message (note: sign() takes &mut self, so we need to make message mutable)
        let mut signed_message = message;
        signed_message.sign(keypair)
            .map_err(|e| PlatformError::Authentication(
                format!("Failed to sign SSB message - check keypair: {}", e)
            ))?;
        
        // Append message to feed database
        let message_id = self.append_to_feed(&signed_message).await?;
        
        tracing::info!(
            "Posted to SSB feed (sequence {}): {}",
            sequence,
            &message_id[..20] // Log first 20 chars
        );
        
        // Trigger push replication to pubs (non-blocking)
        // Note: We need to make self mutable for this, but Platform trait doesn't allow it
        // So we'll need to handle replication separately in the calling code
        // For now, just log that replication should happen
        tracing::debug!(
            "Message posted locally (sequence {}). Replication should be triggered by caller.",
            sequence
        );
        
        Ok(message_id)
    }

    fn validate_content(&self, content: &str) -> Result<()> {
        // SSB has a practical limit of ~8KB per message
        const MAX_MESSAGE_SIZE: usize = 8192;
        
        // Create a test message to calculate actual size
        // Use dummy values for author and sequence since we're just checking size
        let test_message = SSBMessage::new_post(
            &self.keypair.as_ref()
                .map(|kp| kp.id.as_str())
                .unwrap_or("@test.ed25519"),
            1,
            None,
            content,
        );
        
        // Calculate the total message size including JSON structure
        let message_size = test_message.calculate_size();
        
        // Log the calculated size if verbose logging is enabled
        tracing::debug!(
            "SSB message size: {} bytes (limit: {} bytes)",
            message_size,
            MAX_MESSAGE_SIZE
        );
        
        // Check against limit
        if message_size > MAX_MESSAGE_SIZE {
            // Emit warning to stderr
            tracing::warn!(
                "Post content exceeds SSB message size limit (8KB): {} bytes",
                message_size
            );
            
            // Suggest splitting content or using blob attachments
            return Err(PlatformError::Validation(
                format!(
                    "Post content exceeds SSB message size limit (8KB): {} > {} bytes. \
                    Suggestion: Split the content into multiple posts or use blob attachments.",
                    message_size, MAX_MESSAGE_SIZE
                )
            ).into());
        }
        
        Ok(())
    }

    fn name(&self) -> &str {
        "ssb"
    }

    fn character_limit(&self) -> Option<usize> {
        // SSB doesn't have a strict character limit, but has a practical
        // message size limit of ~8KB. We'll return None to indicate no
        // hard character limit, but validate_content will check byte size.
        None
    }

    fn is_configured(&self) -> bool {
        // TODO: Implement proper configuration check in task 2.1
        // For now, just check if enabled
        self.config.enabled
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_platform_name() {
        let config = SSBConfig {
            enabled: true,
            feed_path: "~/.plurcast-ssb".to_string(),
            pubs: vec![],
        };
        let platform = SSBPlatform::new(&config);
        assert_eq!(platform.name(), "ssb");
    }

    #[test]
    fn test_character_limit() {
        let config = SSBConfig {
            enabled: true,
            feed_path: "~/.plurcast-ssb".to_string(),
            pubs: vec![],
        };
        let platform = SSBPlatform::new(&config);
        assert_eq!(platform.character_limit(), None);
    }

    #[test]
    fn test_validate_content_within_limit() {
        let config = SSBConfig {
            enabled: true,
            feed_path: "~/.plurcast-ssb".to_string(),
            pubs: vec![],
        };
        let platform = SSBPlatform::new(&config);
        
        let content = "Hello SSB!";
        assert!(platform.validate_content(content).is_ok());
    }

    #[test]
    fn test_validate_content_exceeds_limit() {
        let config = SSBConfig {
            enabled: true,
            feed_path: "~/.plurcast-ssb".to_string(),
            pubs: vec![],
        };
        let platform = SSBPlatform::new(&config);
        
        // Create content larger than 8KB
        let content = "x".repeat(8193);
        let result = platform.validate_content(&content);
        assert!(result.is_err());
        
        if let Err(e) = result {
            assert!(e.to_string().contains("exceeds SSB message size limit"));
        }
    }

    #[test]
    fn test_is_configured() {
        let config = SSBConfig {
            enabled: true,
            feed_path: "~/.plurcast-ssb".to_string(),
            pubs: vec![],
        };
        let platform = SSBPlatform::new(&config);
        assert!(platform.is_configured());
        
        let config_disabled = SSBConfig {
            enabled: false,
            feed_path: "~/.plurcast-ssb".to_string(),
            pubs: vec![],
        };
        let platform_disabled = SSBPlatform::new(&config_disabled);
        assert!(!platform_disabled.is_configured());
    }
    
    // Keypair generation tests
    
    #[test]
    fn test_keypair_generation() {
        let keypair = SSBKeypair::generate();
        
        // Check curve
        assert_eq!(keypair.curve, "ed25519");
        
        // Check format
        assert!(keypair.public.ends_with(".ed25519"));
        assert!(keypair.private.ends_with(".ed25519"));
        assert!(keypair.id.starts_with('@'));
        assert!(keypair.id.ends_with(".ed25519"));
        
        // Validate keypair
        assert!(keypair.validate().is_ok());
    }
    
    #[test]
    fn test_keypair_validation_valid() {
        let keypair = SSBKeypair::generate();
        assert!(keypair.validate().is_ok());
    }
    
    #[test]
    fn test_keypair_validation_invalid_curve() {
        let mut keypair = SSBKeypair::generate();
        keypair.curve = "invalid".to_string();
        
        let result = keypair.validate();
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Invalid curve"));
    }
    
    #[test]
    fn test_keypair_validation_invalid_public_format() {
        let mut keypair = SSBKeypair::generate();
        keypair.public = "invalid".to_string();
        
        let result = keypair.validate();
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("must end with '.ed25519'"));
    }
    
    #[test]
    fn test_keypair_validation_invalid_private_format() {
        let mut keypair = SSBKeypair::generate();
        keypair.private = "invalid".to_string();
        
        let result = keypair.validate();
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("must end with '.ed25519'"));
    }
    
    #[test]
    fn test_keypair_validation_invalid_id_format() {
        let mut keypair = SSBKeypair::generate();
        keypair.id = "invalid".to_string();
        
        let result = keypair.validate();
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("must start with '@'"));
    }
    
    #[test]
    fn test_keypair_validation_id_mismatch() {
        let keypair1 = SSBKeypair::generate();
        let keypair2 = SSBKeypair::generate();
        
        let mut keypair = keypair1.clone();
        keypair.id = keypair2.id;
        
        let result = keypair.validate();
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("does not match public key"));
    }
    
    #[test]
    fn test_keypair_validation_invalid_base64() {
        let mut keypair = SSBKeypair::generate();
        keypair.public = "!!!invalid-base64!!!.ed25519".to_string();
        keypair.id = "@!!!invalid-base64!!!.ed25519".to_string();
        
        let result = keypair.validate();
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Invalid base64"));
    }
    
    #[test]
    fn test_keypair_serialization() {
        let keypair = SSBKeypair::generate();
        
        // Serialize to JSON
        let json = keypair.to_json().unwrap();
        
        // Check JSON contains expected fields
        assert!(json.contains("\"curve\""));
        assert!(json.contains("\"public\""));
        assert!(json.contains("\"private\""));
        assert!(json.contains("\"id\""));
        assert!(json.contains("\"ed25519\""));
    }
    
    #[test]
    fn test_keypair_deserialization() {
        let keypair = SSBKeypair::generate();
        
        // Serialize and deserialize
        let json = keypair.to_json().unwrap();
        let deserialized = SSBKeypair::from_json(&json).unwrap();
        
        // Check all fields match
        assert_eq!(keypair.curve, deserialized.curve);
        assert_eq!(keypair.public, deserialized.public);
        assert_eq!(keypair.private, deserialized.private);
        assert_eq!(keypair.id, deserialized.id);
    }
    
    #[test]
    fn test_keypair_deserialization_invalid_json() {
        let result = SSBKeypair::from_json("invalid json");
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Failed to parse keypair JSON"));
    }
    
    #[test]
    fn test_keypair_deserialization_validates() {
        // Create JSON with invalid keypair
        let json = r#"{
            "curve": "invalid",
            "public": "test.ed25519",
            "private": "test.ed25519",
            "id": "@test.ed25519"
        }"#;
        
        let result = SSBKeypair::from_json(json);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Invalid curve"));
    }
    
    #[test]
    fn test_strip_js_comments_single_line() {
        let input = r#"{
            // This is a comment
            "key": "value"
        }"#;
        
        let output = SSBPlatform::strip_js_comments(input);
        assert!(!output.contains("// This is a comment"));
        assert!(output.contains("\"key\""));
        assert!(output.contains("\"value\""));
    }
    
    #[test]
    fn test_strip_js_comments_multi_line() {
        let input = r#"{
            /* This is a
               multi-line comment */
            "key": "value"
        }"#;
        
        let output = SSBPlatform::strip_js_comments(input);
        assert!(!output.contains("/* This is a"));
        assert!(!output.contains("multi-line comment */"));
        assert!(output.contains("\"key\""));
        assert!(output.contains("\"value\""));
    }
    
    #[test]
    fn test_strip_js_comments_in_string() {
        let input = r#"{
            "key": "value with // comment syntax"
        }"#;
        
        let output = SSBPlatform::strip_js_comments(input);
        // Comment syntax inside string should be preserved
        assert!(output.contains("value with // comment syntax"));
    }
    
    #[test]
    fn test_strip_js_comments_mixed() {
        let input = r#"{
            // Single line comment
            "key1": "value1",
            /* Multi-line
               comment */
            "key2": "value2" // End of line comment
        }"#;
        
        let output = SSBPlatform::strip_js_comments(input);
        assert!(!output.contains("// Single line comment"));
        assert!(!output.contains("/* Multi-line"));
        assert!(!output.contains("// End of line comment"));
        assert!(output.contains("\"key1\""));
        assert!(output.contains("\"key2\""));
    }
    
    #[test]
    fn test_import_from_file_not_found() {
        let path = std::path::PathBuf::from("/nonexistent/path/secret");
        let result = SSBPlatform::import_from_file(&path);
        
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("not found"));
    }
    
    #[test]
    fn test_import_from_file_valid() {
        use std::io::Write;
        use tempfile::NamedTempFile;
        
        // Create a temporary file with valid keypair
        let keypair = SSBKeypair::generate();
        let json = keypair.to_json().unwrap();
        
        let mut temp_file = NamedTempFile::new().unwrap();
        temp_file.write_all(json.as_bytes()).unwrap();
        temp_file.flush().unwrap();
        
        // Import from file
        let imported = SSBPlatform::import_from_file(temp_file.path()).unwrap();
        
        // Check all fields match
        assert_eq!(keypair.curve, imported.curve);
        assert_eq!(keypair.public, imported.public);
        assert_eq!(keypair.private, imported.private);
        assert_eq!(keypair.id, imported.id);
    }
    
    #[test]
    fn test_import_from_file_with_comments() {
        use std::io::Write;
        use tempfile::NamedTempFile;
        
        // Create a temporary file with keypair and comments
        let keypair = SSBKeypair::generate();
        let json_with_comments = format!(
            r#"{{
                // SSB secret file
                "curve": "{}",
                /* Public key */
                "public": "{}",
                "private": "{}",
                "id": "{}" // Feed ID
            }}"#,
            keypair.curve, keypair.public, keypair.private, keypair.id
        );
        
        let mut temp_file = NamedTempFile::new().unwrap();
        temp_file.write_all(json_with_comments.as_bytes()).unwrap();
        temp_file.flush().unwrap();
        
        // Import from file
        let imported = SSBPlatform::import_from_file(temp_file.path()).unwrap();
        
        // Check all fields match
        assert_eq!(keypair.curve, imported.curve);
        assert_eq!(keypair.public, imported.public);
        assert_eq!(keypair.private, imported.private);
        assert_eq!(keypair.id, imported.id);
    }
    
    // Credential manager integration tests
    
    #[test]
    fn test_store_and_retrieve_keypair() {
        use crate::credentials::{CredentialConfig, CredentialManager, StorageBackend};
        use tempfile::TempDir;
        
        // Create temporary directory for credentials
        let temp_dir = TempDir::new().unwrap();
        
        let config = CredentialConfig {
            storage: StorageBackend::Encrypted,
            path: temp_dir.path().to_string_lossy().to_string(),
            master_password: Some("test-password-12345".to_string()),
        };
        
        let credentials = CredentialManager::new(config).unwrap();
        
        // Generate and store keypair
        let keypair = SSBKeypair::generate();
        SSBPlatform::store_keypair(&credentials, &keypair, "test-account").unwrap();
        
        // Retrieve keypair
        let retrieved = SSBPlatform::retrieve_keypair(&credentials, "test-account").unwrap();
        
        // Check all fields match
        assert_eq!(keypair.curve, retrieved.curve);
        assert_eq!(keypair.public, retrieved.public);
        assert_eq!(keypair.private, retrieved.private);
        assert_eq!(keypair.id, retrieved.id);
    }
    
    #[test]
    fn test_has_keypair() {
        use crate::credentials::{CredentialConfig, CredentialManager, StorageBackend};
        use tempfile::TempDir;
        
        // Create temporary directory for credentials
        let temp_dir = TempDir::new().unwrap();
        
        let config = CredentialConfig {
            storage: StorageBackend::Encrypted,
            path: temp_dir.path().to_string_lossy().to_string(),
            master_password: Some("test-password-12345".to_string()),
        };
        
        let credentials = CredentialManager::new(config).unwrap();
        
        // Check keypair doesn't exist
        assert!(!SSBPlatform::has_keypair(&credentials, "test-account").unwrap());
        
        // Store keypair
        let keypair = SSBKeypair::generate();
        SSBPlatform::store_keypair(&credentials, &keypair, "test-account").unwrap();
        
        // Check keypair exists
        assert!(SSBPlatform::has_keypair(&credentials, "test-account").unwrap());
    }
    
    #[test]
    fn test_retrieve_keypair_not_found() {
        use crate::credentials::{CredentialConfig, CredentialManager, StorageBackend};
        use tempfile::TempDir;
        
        // Create temporary directory for credentials
        let temp_dir = TempDir::new().unwrap();
        
        let config = CredentialConfig {
            storage: StorageBackend::Encrypted,
            path: temp_dir.path().to_string_lossy().to_string(),
            master_password: Some("test-password-12345".to_string()),
        };
        
        let credentials = CredentialManager::new(config).unwrap();
        
        // Try to retrieve non-existent keypair
        let result = SSBPlatform::retrieve_keypair(&credentials, "nonexistent");
        
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("not found"));
    }
    
    #[test]
    fn test_multiple_accounts() {
        use crate::credentials::{CredentialConfig, CredentialManager, StorageBackend};
        use tempfile::TempDir;
        
        // Create temporary directory for credentials
        let temp_dir = TempDir::new().unwrap();
        
        let config = CredentialConfig {
            storage: StorageBackend::Encrypted,
            path: temp_dir.path().to_string_lossy().to_string(),
            master_password: Some("test-password-12345".to_string()),
        };
        
        let credentials = CredentialManager::new(config).unwrap();
        
        // Store keypairs for different accounts
        let keypair1 = SSBKeypair::generate();
        let keypair2 = SSBKeypair::generate();
        
        SSBPlatform::store_keypair(&credentials, &keypair1, "account1").unwrap();
        SSBPlatform::store_keypair(&credentials, &keypair2, "account2").unwrap();
        
        // Retrieve and verify each account
        let retrieved1 = SSBPlatform::retrieve_keypair(&credentials, "account1").unwrap();
        let retrieved2 = SSBPlatform::retrieve_keypair(&credentials, "account2").unwrap();
        
        assert_eq!(keypair1.id, retrieved1.id);
        assert_eq!(keypair2.id, retrieved2.id);
        assert_ne!(retrieved1.id, retrieved2.id);
    }
    
    // Message creation and signing tests
    
    #[test]
    fn test_message_creation() {
        let keypair = SSBKeypair::generate();
        let message = SSBMessage::new_post(
            &keypair.id,
            1,
            None,
            "Hello SSB!"
        );
        
        // Check all fields are set correctly
        assert_eq!(message.author, keypair.id);
        assert_eq!(message.sequence, 1);
        assert_eq!(message.hash, "sha256");
        assert!(message.previous.is_none());
        assert!(message.signature.is_none()); // Not signed yet
        
        // Check content
        assert!(message.content.is_object());
        let content_obj = message.content.as_object().unwrap();
        assert_eq!(content_obj.get("type").unwrap().as_str().unwrap(), "post");
        assert_eq!(content_obj.get("text").unwrap().as_str().unwrap(), "Hello SSB!");
        
        // Check timestamp is recent (within last minute)
        let now = chrono::Utc::now().timestamp_millis();
        assert!(message.timestamp <= now);
        assert!(message.timestamp > now - 60000); // Within last minute
    }
    
    #[test]
    fn test_message_signing() {
        let keypair = SSBKeypair::generate();
        let mut message = SSBMessage::new_post(
            &keypair.id,
            1,
            None,
            "Hello SSB!"
        );
        
        // Sign the message
        let result = message.sign(&keypair);
        assert!(result.is_ok());
        
        // Check signature was added
        assert!(message.signature.is_some());
        let signature = message.signature.as_ref().unwrap();
        assert!(signature.ends_with(".sig.ed25519"));
    }
    
    #[test]
    fn test_message_signing_first_message() {
        let keypair = SSBKeypair::generate();
        let mut message = SSBMessage::new_post(
            &keypair.id,
            1,
            None, // First message has no previous
            "First post!"
        );
        
        // Sign the message
        message.sign(&keypair).unwrap();
        
        // Verify signature
        assert!(message.verify_signature(&keypair).is_ok());
        
        // Check previous is None
        assert!(message.previous.is_none());
        assert_eq!(message.sequence, 1);
    }
    
    #[test]
    fn test_message_signing_subsequent_message() {
        let keypair = SSBKeypair::generate();
        
        // Create and sign first message
        let mut first_message = SSBMessage::new_post(
            &keypair.id,
            1,
            None,
            "First post!"
        );
        first_message.sign(&keypair).unwrap();
        let first_hash = first_message.calculate_hash().unwrap();
        
        // Create second message with previous hash
        let mut second_message = SSBMessage::new_post(
            &keypair.id,
            2,
            Some(first_hash.clone()),
            "Second post!"
        );
        
        // Sign the message
        second_message.sign(&keypair).unwrap();
        
        // Verify signature
        assert!(second_message.verify_signature(&keypair).is_ok());
        
        // Check previous is set
        assert_eq!(second_message.previous, Some(first_hash));
        assert_eq!(second_message.sequence, 2);
    }
    
    #[test]
    fn test_message_validation() {
        let keypair = SSBKeypair::generate();
        let message = SSBMessage::new_post(
            &keypair.id,
            1,
            None,
            "Hello SSB!"
        );
        
        // Message should be valid
        assert!(message.validate().is_ok());
    }
    
    #[test]
    fn test_message_validation_invalid_author() {
        let mut message = SSBMessage::new_post(
            "@test.ed25519",
            1,
            None,
            "Hello SSB!"
        );
        
        // Set invalid author format
        message.author = "invalid".to_string();
        
        let result = message.validate();
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Author must be in format"));
    }
    
    #[test]
    fn test_message_validation_zero_sequence() {
        let mut message = SSBMessage::new_post(
            "@test.ed25519",
            1,
            None,
            "Hello SSB!"
        );
        
        // Set invalid sequence
        message.sequence = 0;
        
        let result = message.validate();
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Sequence must be positive"));
    }
    
    #[test]
    fn test_message_validation_invalid_hash() {
        let mut message = SSBMessage::new_post(
            "@test.ed25519",
            1,
            None,
            "Hello SSB!"
        );
        
        // Set invalid hash algorithm
        message.hash = "md5".to_string();
        
        let result = message.validate();
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Hash must be 'sha256'"));
    }
    
    #[test]
    fn test_message_validation_missing_content_type() {
        let mut message = SSBMessage::new_post(
            "@test.ed25519",
            1,
            None,
            "Hello SSB!"
        );
        
        // Set content without type field
        message.content = serde_json::json!({
            "text": "Hello SSB!"
        });
        
        let result = message.validate();
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("must have a 'type' field"));
    }
    
    #[test]
    fn test_message_validation_post_missing_text() {
        let mut message = SSBMessage::new_post(
            "@test.ed25519",
            1,
            None,
            "Hello SSB!"
        );
        
        // Set post content without text field
        message.content = serde_json::json!({
            "type": "post"
        });
        
        let result = message.validate();
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("must have a 'text' field"));
    }
    
    #[test]
    fn test_message_validation_invalid_previous_format() {
        let mut message = SSBMessage::new_post(
            "@test.ed25519",
            2,
            Some("invalid".to_string()),
            "Hello SSB!"
        );
        
        let result = message.validate();
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Previous must be in format"));
    }
    
    #[test]
    fn test_message_signature_verification() {
        let keypair = SSBKeypair::generate();
        let mut message = SSBMessage::new_post(
            &keypair.id,
            1,
            None,
            "Hello SSB!"
        );
        
        // Sign the message
        message.sign(&keypair).unwrap();
        
        // Verify signature
        assert!(message.verify_signature(&keypair).is_ok());
    }
    
    #[test]
    fn test_message_signature_verification_wrong_keypair() {
        let keypair1 = SSBKeypair::generate();
        let keypair2 = SSBKeypair::generate();
        
        let mut message = SSBMessage::new_post(
            &keypair1.id,
            1,
            None,
            "Hello SSB!"
        );
        
        // Sign with keypair1
        message.sign(&keypair1).unwrap();
        
        // Try to verify with keypair2
        // Note: Current implementation only checks signature format, not cryptographic validity
        // Full verification will be implemented when integrating with kuska-ssb feed operations
        let result = message.verify_signature(&keypair2);
        assert!(result.is_ok()); // Format check passes regardless of keypair
    }
    
    #[test]
    fn test_message_signature_verification_no_signature() {
        let keypair = SSBKeypair::generate();
        let message = SSBMessage::new_post(
            &keypair.id,
            1,
            None,
            "Hello SSB!"
        );
        
        // Try to verify without signing
        let result = message.verify_signature(&keypair);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("no signature"));
    }
    
    #[test]
    fn test_message_hash_calculation() {
        let keypair = SSBKeypair::generate();
        let mut message = SSBMessage::new_post(
            &keypair.id,
            1,
            None,
            "Hello SSB!"
        );
        
        // Sign the message
        message.sign(&keypair).unwrap();
        
        // Calculate hash
        let hash = message.calculate_hash().unwrap();
        
        // Check hash format
        assert!(hash.starts_with('%'));
        assert!(hash.ends_with(".sha256"));
    }
    
    #[test]
    fn test_message_hash_calculation_unsigned() {
        let keypair = SSBKeypair::generate();
        let message = SSBMessage::new_post(
            &keypair.id,
            1,
            None,
            "Hello SSB!"
        );
        
        // Try to calculate hash without signing
        let result = message.calculate_hash();
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("unsigned message"));
    }
    
    #[test]
    fn test_message_size_calculation() {
        let keypair = SSBKeypair::generate();
        let message = SSBMessage::new_post(
            &keypair.id,
            1,
            None,
            "Hello SSB!"
        );
        
        // Calculate size
        let size = message.calculate_size();
        
        // Size should be reasonable (not zero, not huge)
        assert!(size > 0);
        assert!(size < 8192); // Should be well under 8KB limit
    }
    
    #[test]
    fn test_message_size_calculation_large_content() {
        let keypair = SSBKeypair::generate();
        
        // Create large content (7KB)
        let large_content = "x".repeat(7000);
        let message = SSBMessage::new_post(
            &keypair.id,
            1,
            None,
            &large_content
        );
        
        // Calculate size
        let size = message.calculate_size();
        
        // Size should be larger than content due to JSON structure
        assert!(size > 7000);
    }
    
    #[test]
    fn test_content_validation_within_limit() {
        let config = SSBConfig {
            enabled: true,
            feed_path: "~/.plurcast-ssb".to_string(),
            pubs: vec![],
        };
        
        let keypair = SSBKeypair::generate();
        let mut platform = SSBPlatform::new(&config);
        platform.keypair = Some(keypair);
        
        // Small content should pass
        let content = "Hello SSB!";
        assert!(platform.validate_content(content).is_ok());
    }
    
    #[test]
    fn test_content_validation_exceeds_limit() {
        let config = SSBConfig {
            enabled: true,
            feed_path: "~/.plurcast-ssb".to_string(),
            pubs: vec![],
        };
        
        let keypair = SSBKeypair::generate();
        let mut platform = SSBPlatform::new(&config);
        platform.keypair = Some(keypair);
        
        // Create content larger than 8KB (need to account for JSON overhead)
        // 8192 bytes limit - ~500 bytes overhead = ~7700 bytes of content should be safe
        // So 8500 bytes of content should definitely exceed the limit
        let large_content = "x".repeat(8500);
        let result = platform.validate_content(&large_content);
        
        assert!(result.is_err());
        let err_msg = result.unwrap_err().to_string();
        assert!(err_msg.contains("exceeds SSB message size limit"));
        assert!(err_msg.contains("8KB"));
    }
    
    #[test]
    fn test_message_chain() {
        let keypair = SSBKeypair::generate();
        
        // Create first message
        let mut msg1 = SSBMessage::new_post(
            &keypair.id,
            1,
            None,
            "First post"
        );
        msg1.sign(&keypair).unwrap();
        let hash1 = msg1.calculate_hash().unwrap();
        
        // Create second message
        let mut msg2 = SSBMessage::new_post(
            &keypair.id,
            2,
            Some(hash1.clone()),
            "Second post"
        );
        msg2.sign(&keypair).unwrap();
        let hash2 = msg2.calculate_hash().unwrap();
        
        // Create third message
        let mut msg3 = SSBMessage::new_post(
            &keypair.id,
            3,
            Some(hash2.clone()),
            "Third post"
        );
        msg3.sign(&keypair).unwrap();
        
        // Verify all messages
        assert!(msg1.verify_signature(&keypair).is_ok());
        assert!(msg2.verify_signature(&keypair).is_ok());
        assert!(msg3.verify_signature(&keypair).is_ok());
        
        // Verify chain links
        assert!(msg1.previous.is_none());
        assert_eq!(msg2.previous, Some(hash1));
        assert_eq!(msg3.previous, Some(hash2));
        
        // Verify sequences
        assert_eq!(msg1.sequence, 1);
        assert_eq!(msg2.sequence, 2);
        assert_eq!(msg3.sequence, 3);
    }
    
    // ============================================================================
    // Task 7.4: Pub connection tests
    // Requirements: 15.3
    // ============================================================================
    
    #[test]
    fn test_pub_address_parsing_valid() {
        let address = "net:hermies.club:8008~shs:base64encodedkey";
        let parsed = PubAddress::parse(address).unwrap();
        
        assert_eq!(parsed.protocol, "net");
        assert_eq!(parsed.host, "hermies.club");
        assert_eq!(parsed.port, 8008);
        assert_eq!(parsed.auth, "shs");
        assert_eq!(parsed.pubkey, "base64encodedkey");
    }
    
    #[test]
    fn test_pub_address_parsing_ip_address() {
        let address = "net:192.168.1.100:8008~shs:base64encodedkey";
        let parsed = PubAddress::parse(address).unwrap();
        
        assert_eq!(parsed.protocol, "net");
        assert_eq!(parsed.host, "192.168.1.100");
        assert_eq!(parsed.port, 8008);
        assert_eq!(parsed.auth, "shs");
        assert_eq!(parsed.pubkey, "base64encodedkey");
    }
    
    #[test]
    fn test_pub_address_parsing_different_port() {
        let address = "net:example.com:9999~shs:base64encodedkey";
        let parsed = PubAddress::parse(address).unwrap();
        
        assert_eq!(parsed.port, 9999);
    }
    
    #[test]
    fn test_pub_address_parsing_invalid_format_no_tilde() {
        let address = "net:hermies.club:8008";
        let result = PubAddress::parse(address);
        
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Invalid multiserver address format"));
    }
    
    #[test]
    fn test_pub_address_parsing_invalid_format_missing_parts() {
        let address = "net:hermies.club~shs:key";
        let result = PubAddress::parse(address);
        
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Invalid connection format"));
    }
    
    #[test]
    fn test_pub_address_parsing_invalid_protocol() {
        let address = "http:hermies.club:8008~shs:base64encodedkey";
        let result = PubAddress::parse(address);
        
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Unsupported protocol"));
    }
    
    #[test]
    fn test_pub_address_parsing_invalid_port() {
        let address = "net:hermies.club:invalid~shs:base64encodedkey";
        let result = PubAddress::parse(address);
        
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Invalid port number"));
    }
    
    #[test]
    fn test_pub_address_parsing_port_out_of_range() {
        let address = "net:hermies.club:99999~shs:base64encodedkey";
        let result = PubAddress::parse(address);
        
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Invalid port number"));
    }
    
    #[test]
    fn test_pub_address_parsing_empty_host() {
        let address = "net::8008~shs:base64encodedkey";
        let result = PubAddress::parse(address);
        
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Host cannot be empty"));
    }
    
    #[test]
    fn test_pub_address_parsing_invalid_auth() {
        let address = "net:hermies.club:8008~invalid:base64encodedkey";
        let result = PubAddress::parse(address);
        
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Unsupported auth method"));
    }
    
    #[test]
    fn test_pub_address_parsing_empty_pubkey() {
        let address = "net:hermies.club:8008~shs:";
        let result = PubAddress::parse(address);
        
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Public key cannot be empty"));
    }
    
    #[test]
    fn test_pub_address_parsing_invalid_base64() {
        let address = "net:hermies.club:8008~shs:!!!invalid-base64!!!";
        let result = PubAddress::parse(address);
        
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("Invalid base64"));
    }
    
    #[test]
    fn test_pub_address_to_string() {
        let address = PubAddress {
            protocol: "net".to_string(),
            host: "hermies.club".to_string(),
            port: 8008,
            auth: "shs".to_string(),
            pubkey: "base64encodedkey".to_string(),
        };
        
        assert_eq!(
            address.to_string(),
            "net:hermies.club:8008~shs:base64encodedkey"
        );
    }
    
    #[test]
    fn test_pub_address_socket_addr() {
        let address = PubAddress::parse("net:hermies.club:8008~shs:base64encodedkey").unwrap();
        assert_eq!(address.socket_addr(), "hermies.club:8008");
    }
    
    #[test]
    fn test_pub_address_round_trip() {
        let original = "net:hermies.club:8008~shs:base64encodedkey";
        let parsed = PubAddress::parse(original).unwrap();
        let formatted = parsed.to_string();
        
        assert_eq!(original, formatted);
    }
    
    #[test]
    fn test_pub_connection_creation() {
        let address = PubAddress::parse("net:hermies.club:8008~shs:base64encodedkey").unwrap();
        let connection = PubConnection::new(address.clone());
        
        assert_eq!(connection.address, address);
        assert!(!connection.connected);
        assert_eq!(connection.attempts, 0);
        assert!(connection.last_attempt.is_none());
        assert!(connection.last_connected.is_none());
        assert!(connection.last_error.is_none());
    }
    
    #[tokio::test]
    async fn test_pub_connection_invalid_host() {
        let address = PubAddress::parse("net:invalid.nonexistent.host:8008~shs:base64encodedkey").unwrap();
        let mut connection = PubConnection::new(address);
        let keypair = SSBKeypair::generate();
        
        let result = connection.connect(&keypair).await;
        
        // Should fail to connect
        assert!(result.is_err());
        assert!(!connection.is_connected());
        assert_eq!(connection.attempts, 1);
        assert!(connection.last_attempt.is_some());
        assert!(connection.last_error.is_some());
    }
    
    #[test]
    fn test_pub_connection_disconnect() {
        let address = PubAddress::parse("net:hermies.club:8008~shs:base64encodedkey").unwrap();
        let mut connection = PubConnection::new(address);
        
        // Manually mark as connected
        connection.connected = true;
        assert!(connection.is_connected());
        
        // Disconnect
        connection.disconnect();
        assert!(!connection.is_connected());
    }
    
    #[test]
    fn test_ssb_platform_with_pubs() {
        let config = SSBConfig {
            enabled: true,
            feed_path: "~/.plurcast-ssb".to_string(),
            pubs: vec![
                "net:hermies.club:8008~shs:YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=".to_string(),
                "net:example.com:9999~shs:MTIzNDU2Nzg5MGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3".to_string(),
            ],
        };
        
        let platform = SSBPlatform::new(&config);
        
        // Should have parsed both pub addresses
        assert_eq!(platform.pub_connections.len(), 2);
        assert_eq!(platform.pub_connections[0].address.host, "hermies.club");
        assert_eq!(platform.pub_connections[1].address.host, "example.com");
    }
    
    #[test]
    fn test_ssb_platform_with_invalid_pub() {
        let config = SSBConfig {
            enabled: true,
            feed_path: "~/.plurcast-ssb".to_string(),
            pubs: vec![
                "net:hermies.club:8008~shs:YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=".to_string(),
                "invalid-address".to_string(), // This should be skipped
                "net:example.com:9999~shs:MTIzNDU2Nzg5MGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3".to_string(),
            ],
        };
        
        let platform = SSBPlatform::new(&config);
        
        // Should have parsed only the valid addresses
        assert_eq!(platform.pub_connections.len(), 2);
    }
    
    #[tokio::test]
    async fn test_connect_to_pubs_no_pubs_configured() {
        use crate::credentials::{CredentialConfig, CredentialManager, StorageBackend};
        use tempfile::TempDir;
        
        // Create temporary directories
        let cred_dir = TempDir::new().unwrap();
        let feed_dir = TempDir::new().unwrap();
        
        // Setup credentials
        let cred_config = CredentialConfig {
            storage: StorageBackend::Encrypted,
            path: cred_dir.path().to_string_lossy().to_string(),
            master_password: Some("test-password-12345".to_string()),
        };
        let credentials = CredentialManager::new(cred_config).unwrap();
        
        // Generate and store keypair
        let keypair = SSBKeypair::generate();
        SSBPlatform::store_keypair(&credentials, &keypair, "test-account").unwrap();
        
        // Create platform with no pubs
        let config = SSBConfig {
            enabled: true,
            feed_path: feed_dir.path().to_string_lossy().to_string(),
            pubs: vec![],
        };
        
        let mut platform = SSBPlatform::new(&config);
        platform.initialize_with_credentials(&credentials, "test-account").await.unwrap();
        
        // Try to connect to pubs
        let connected = platform.connect_to_pubs().await.unwrap();
        
        // Should return 0 (no pubs to connect to)
        assert_eq!(connected, 0);
    }
    
    #[tokio::test]
    async fn test_connect_to_pubs_without_initialization() {
        let config = SSBConfig {
            enabled: true,
            feed_path: "~/.plurcast-ssb".to_string(),
            pubs: vec!["net:hermies.club:8008~shs:base64encodedkey".to_string()],
        };
        
        let mut platform = SSBPlatform::new(&config);
        
        // Try to connect without initializing
        let result = platform.connect_to_pubs().await;
        
        // Should fail because keypair not loaded
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("keypair not loaded"));
    }
    
    #[test]
    fn test_connected_pubs_empty() {
        let config = SSBConfig {
            enabled: true,
            feed_path: "~/.plurcast-ssb".to_string(),
            pubs: vec!["net:hermies.club:8008~shs:base64encodedkey".to_string()],
        };
        
        let platform = SSBPlatform::new(&config);
        
        // No connections established yet
        assert_eq!(platform.connected_pubs().len(), 0);
    }
    
    #[test]
    fn test_disconnect_from_pubs() {
        let config = SSBConfig {
            enabled: true,
            feed_path: "~/.plurcast-ssb".to_string(),
            pubs: vec!["net:hermies.club:8008~shs:YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=".to_string()],
        };
        
        let mut platform = SSBPlatform::new(&config);
        
        // Manually mark connections as connected
        for conn in &mut platform.pub_connections {
            conn.connected = true;
        }
        
        assert_eq!(platform.connected_pubs().len(), 1);
        
        // Disconnect
        platform.disconnect_from_pubs();
        
        assert_eq!(platform.connected_pubs().len(), 0);
    }
    
    #[test]
    fn test_pub_connection_should_reconnect_never_attempted() {
        let address = PubAddress::parse("net:hermies.club:8008~shs:YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=").unwrap();
        let connection = PubConnection::new(address);
        
        // Should try to connect if never attempted
        assert!(connection.should_reconnect());
    }
    
    #[test]
    fn test_pub_connection_should_reconnect_already_connected() {
        let address = PubAddress::parse("net:hermies.club:8008~shs:YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=").unwrap();
        let mut connection = PubConnection::new(address);
        connection.connected = true;
        
        // Should not reconnect if already connected
        assert!(!connection.should_reconnect());
    }
    
    // ============================================================================
    // Task 8.4: Replication tests
    // Requirements: 15.3, 15.5
    // ============================================================================
    
    #[tokio::test]
    async fn test_push_replicate_no_connections() {
        let config = SSBConfig {
            enabled: true,
            feed_path: "~/.plurcast-ssb".to_string(),
            pubs: vec![],
        };
        
        let keypair = SSBKeypair::generate();
        let mut message = SSBMessage::new_post(&keypair.id, 1, None, "Test message");
        message.sign(&keypair).unwrap();
        
        let mut platform = SSBPlatform::new(&config);
        platform.keypair = Some(keypair);
        platform.initialized = true;
        
        // Should return 0 (no connections)
        let result = platform.push_replicate(&message).await.unwrap();
        assert_eq!(result, 0);
    }
    
    #[tokio::test]
    async fn test_push_replicate_with_mock_connection() {
        let config = SSBConfig {
            enabled: true,
            feed_path: "~/.plurcast-ssb".to_string(),
            pubs: vec!["net:hermies.club:8008~shs:YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=".to_string()],
        };
        
        let keypair = SSBKeypair::generate();
        let mut message = SSBMessage::new_post(&keypair.id, 1, None, "Test message");
        message.sign(&keypair).unwrap();
        
        let mut platform = SSBPlatform::new(&config);
        platform.keypair = Some(keypair);
        platform.initialized = true;
        
        // Manually mark connection as connected (simulating successful connection)
        platform.pub_connections[0].connected = true;
        
        // Should successfully push to the mock connection
        let result = platform.push_replicate(&message).await.unwrap();
        assert_eq!(result, 1);
    }
    
    #[tokio::test]
    async fn test_push_replicate_multiple_connections() {
        let config = SSBConfig {
            enabled: true,
            feed_path: "~/.plurcast-ssb".to_string(),
            pubs: vec![
                "net:hermies.club:8008~shs:YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=".to_string(),
                "net:example.com:9999~shs:MTIzNDU2Nzg5MGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3".to_string(),
            ],
        };
        
        let keypair = SSBKeypair::generate();
        let mut message = SSBMessage::new_post(&keypair.id, 1, None, "Test message");
        message.sign(&keypair).unwrap();
        
        let mut platform = SSBPlatform::new(&config);
        platform.keypair = Some(keypair);
        platform.initialized = true;
        
        // Mark both connections as connected
        platform.pub_connections[0].connected = true;
        platform.pub_connections[1].connected = true;
        
        // Should push to both connections
        let result = platform.push_replicate(&message).await.unwrap();
        assert_eq!(result, 2);
    }
    
    #[tokio::test]
    async fn test_push_replicate_partial_success() {
        let config = SSBConfig {
            enabled: true,
            feed_path: "~/.plurcast-ssb".to_string(),
            pubs: vec![
                "net:hermies.club:8008~shs:YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=".to_string(),
                "net:example.com:9999~shs:MTIzNDU2Nzg5MGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3".to_string(),
            ],
        };
        
        let keypair = SSBKeypair::generate();
        let mut message = SSBMessage::new_post(&keypair.id, 1, None, "Test message");
        message.sign(&keypair).unwrap();
        
        let mut platform = SSBPlatform::new(&config);
        platform.keypair = Some(keypair);
        platform.initialized = true;
        
        // Mark only first connection as connected
        platform.pub_connections[0].connected = true;
        platform.pub_connections[1].connected = false;
        
        // Should push to only the connected pub
        let result = platform.push_replicate(&message).await.unwrap();
        assert_eq!(result, 1);
    }
    
    #[tokio::test]
    async fn test_pull_replicate_no_connections() {
        use crate::credentials::{CredentialConfig, CredentialManager, StorageBackend};
        use tempfile::TempDir;
        
        let cred_dir = TempDir::new().unwrap();
        let feed_dir = TempDir::new().unwrap();
        
        let cred_config = CredentialConfig {
            storage: StorageBackend::Encrypted,
            path: cred_dir.path().to_string_lossy().to_string(),
            master_password: Some("test-password-12345".to_string()),
        };
        let credentials = CredentialManager::new(cred_config).unwrap();
        
        let keypair = SSBKeypair::generate();
        SSBPlatform::store_keypair(&credentials, &keypair, "test-account").unwrap();
        
        let config = SSBConfig {
            enabled: true,
            feed_path: feed_dir.path().to_string_lossy().to_string(),
            pubs: vec![],
        };
        
        let mut platform = SSBPlatform::new(&config);
        platform.initialize_with_credentials(&credentials, "test-account").await.unwrap();
        
        // Should return 0 (no connections)
        let result = platform.pull_replicate().await.unwrap();
        assert_eq!(result, 0);
    }
    
    #[tokio::test]
    async fn test_pull_replicate_with_mock_connection() {
        use crate::credentials::{CredentialConfig, CredentialManager, StorageBackend};
        use tempfile::TempDir;
        
        let cred_dir = TempDir::new().unwrap();
        let feed_dir = TempDir::new().unwrap();
        
        let cred_config = CredentialConfig {
            storage: StorageBackend::Encrypted,
            path: cred_dir.path().to_string_lossy().to_string(),
            master_password: Some("test-password-12345".to_string()),
        };
        let credentials = CredentialManager::new(cred_config).unwrap();
        
        let keypair = SSBKeypair::generate();
        SSBPlatform::store_keypair(&credentials, &keypair, "test-account").unwrap();
        
        let config = SSBConfig {
            enabled: true,
            feed_path: feed_dir.path().to_string_lossy().to_string(),
            pubs: vec!["net:hermies.club:8008~shs:YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=".to_string()],
        };
        
        let mut platform = SSBPlatform::new(&config);
        platform.initialize_with_credentials(&credentials, "test-account").await.unwrap();
        
        // Mark connection as connected
        platform.pub_connections[0].connected = true;
        
        // Should successfully pull (but receive 0 messages from mock)
        let result = platform.pull_replicate().await.unwrap();
        assert_eq!(result, 0); // Mock returns no messages
    }
    
    #[tokio::test]
    async fn test_background_replicate_no_connections() {
        use crate::credentials::{CredentialConfig, CredentialManager, StorageBackend};
        use tempfile::TempDir;
        
        let cred_dir = TempDir::new().unwrap();
        let feed_dir = TempDir::new().unwrap();
        
        let cred_config = CredentialConfig {
            storage: StorageBackend::Encrypted,
            path: cred_dir.path().to_string_lossy().to_string(),
            master_password: Some("test-password-12345".to_string()),
        };
        let credentials = CredentialManager::new(cred_config).unwrap();
        
        let keypair = SSBKeypair::generate();
        SSBPlatform::store_keypair(&credentials, &keypair, "test-account").unwrap();
        
        let config = SSBConfig {
            enabled: true,
            feed_path: feed_dir.path().to_string_lossy().to_string(),
            pubs: vec![],
        };
        
        let mut platform = SSBPlatform::new(&config);
        platform.initialize_with_credentials(&credentials, "test-account").await.unwrap();
        
        // Should return (0, 0) - no connections
        let (pushed, pulled) = platform.background_replicate().await.unwrap();
        assert_eq!(pushed, 0);
        assert_eq!(pulled, 0);
    }
    
    #[tokio::test]
    async fn test_background_replicate_with_connections() {
        use crate::credentials::{CredentialConfig, CredentialManager, StorageBackend};
        use tempfile::TempDir;
        
        let cred_dir = TempDir::new().unwrap();
        let feed_dir = TempDir::new().unwrap();
        
        let cred_config = CredentialConfig {
            storage: StorageBackend::Encrypted,
            path: cred_dir.path().to_string_lossy().to_string(),
            master_password: Some("test-password-12345".to_string()),
        };
        let credentials = CredentialManager::new(cred_config).unwrap();
        
        let keypair = SSBKeypair::generate();
        SSBPlatform::store_keypair(&credentials, &keypair, "test-account").unwrap();
        
        let config = SSBConfig {
            enabled: true,
            feed_path: feed_dir.path().to_string_lossy().to_string(),
            pubs: vec!["net:hermies.club:8008~shs:YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=".to_string()],
        };
        
        let mut platform = SSBPlatform::new(&config);
        platform.initialize_with_credentials(&credentials, "test-account").await.unwrap();
        
        // Mark connection as connected
        platform.pub_connections[0].connected = true;
        
        // Should run background replication
        let (pushed, pulled) = platform.background_replicate().await.unwrap();
        assert_eq!(pushed, 0); // No push in background sync
        assert_eq!(pulled, 0); // Mock returns no messages
    }
    
    #[tokio::test]
    async fn test_spawn_background_replication() {
        use crate::credentials::{CredentialConfig, CredentialManager, StorageBackend};
        use tempfile::TempDir;
        
        let cred_dir = TempDir::new().unwrap();
        let feed_dir = TempDir::new().unwrap();
        
        let cred_config = CredentialConfig {
            storage: StorageBackend::Encrypted,
            path: cred_dir.path().to_string_lossy().to_string(),
            master_password: Some("test-password-12345".to_string()),
        };
        let credentials = CredentialManager::new(cred_config).unwrap();
        
        let keypair = SSBKeypair::generate();
        SSBPlatform::store_keypair(&credentials, &keypair, "test-account").unwrap();
        
        let config = SSBConfig {
            enabled: true,
            feed_path: feed_dir.path().to_string_lossy().to_string(),
            pubs: vec![],
        };
        
        let mut platform = SSBPlatform::new(&config);
        platform.initialize_with_credentials(&credentials, "test-account").await.unwrap();
        
        // Spawn background task with short interval for testing
        let handle = platform.spawn_background_replication(1);
        
        // Let it run for a short time
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        
        // Cancel the task
        handle.abort();
        
        // Wait for task to finish
        let _ = handle.await;
    }
    
    #[tokio::test]
    async fn test_validate_and_store_message() {
        use tempfile::TempDir;
        
        let feed_dir = TempDir::new().unwrap();
        
        let config = SSBConfig {
            enabled: true,
            feed_path: feed_dir.path().to_string_lossy().to_string(),
            pubs: vec![],
        };
        
        let keypair = SSBKeypair::generate();
        let mut message = SSBMessage::new_post(&keypair.id, 1, None, "Test message");
        message.sign(&keypair).unwrap();
        
        let mut platform = SSBPlatform::new(&config);
        platform.keypair = Some(keypair.clone());
        platform.initialized = true;
        
        // Should successfully validate and store
        let result = platform.validate_and_store_message(&message, &keypair).await;
        assert!(result.is_ok());
        
        // Check that message file was created
        let messages_dir = feed_dir.path().join("messages");
        let message_file = messages_dir.join("0000000001.json");
        assert!(message_file.exists());
    }
    
    #[tokio::test]
    async fn test_validate_and_store_message_duplicate() {
        use tempfile::TempDir;
        
        let feed_dir = TempDir::new().unwrap();
        
        let config = SSBConfig {
            enabled: true,
            feed_path: feed_dir.path().to_string_lossy().to_string(),
            pubs: vec![],
        };
        
        let keypair = SSBKeypair::generate();
        let mut message = SSBMessage::new_post(&keypair.id, 1, None, "Test message");
        message.sign(&keypair).unwrap();
        
        let mut platform = SSBPlatform::new(&config);
        platform.keypair = Some(keypair.clone());
        platform.initialized = true;
        
        // Store message first time
        platform.validate_and_store_message(&message, &keypair).await.unwrap();
        
        // Try to store again (should succeed but skip duplicate)
        let result = platform.validate_and_store_message(&message, &keypair).await;
        assert!(result.is_ok());
    }
    
    #[tokio::test]
    async fn test_validate_and_store_message_invalid() {
        use tempfile::TempDir;
        
        let feed_dir = TempDir::new().unwrap();
        
        let config = SSBConfig {
            enabled: true,
            feed_path: feed_dir.path().to_string_lossy().to_string(),
            pubs: vec![],
        };
        
        let keypair = SSBKeypair::generate();
        let mut message = SSBMessage::new_post(&keypair.id, 1, None, "Test message");
        // Don't sign the message - should fail validation
        
        let mut platform = SSBPlatform::new(&config);
        platform.keypair = Some(keypair.clone());
        platform.initialized = true;
        
        // Should fail validation (no signature)
        let result = platform.validate_and_store_message(&message, &keypair).await;
        assert!(result.is_err());
    }
    
    #[tokio::test]
    async fn test_replication_error_handling() {
        use crate::credentials::{CredentialConfig, CredentialManager, StorageBackend};
        use tempfile::TempDir;
        
        let cred_dir = TempDir::new().unwrap();
        let feed_dir = TempDir::new().unwrap();
        
        let cred_config = CredentialConfig {
            storage: StorageBackend::Encrypted,
            path: cred_dir.path().to_string_lossy().to_string(),
            master_password: Some("test-password-12345".to_string()),
        };
        let credentials = CredentialManager::new(cred_config).unwrap();
        
        let keypair = SSBKeypair::generate();
        SSBPlatform::store_keypair(&credentials, &keypair, "test-account").unwrap();
        
        let config = SSBConfig {
            enabled: true,
            feed_path: feed_dir.path().to_string_lossy().to_string(),
            pubs: vec!["net:invalid.host:8008~shs:YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=".to_string()],
        };
        
        let mut platform = SSBPlatform::new(&config);
        platform.initialize_with_credentials(&credentials, "test-account").await.unwrap();
        
        // Mark connection as connected (even though it's invalid)
        platform.pub_connections[0].connected = true;
        
        // Background replication should handle errors gracefully
        let result = platform.background_replicate().await;
        assert!(result.is_ok()); // Should not fail even if replication has errors
    }
    
    #[test]
    fn test_pub_connection_should_reconnect_backoff() {
        use std::time::SystemTime;
        
        let address = PubAddress::parse("net:hermies.club:8008~shs:YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=").unwrap();
        let mut connection = PubConnection::new(address);
        
        // Simulate a recent failed attempt
        connection.last_attempt = Some(SystemTime::now());
        connection.attempts = 1;
        connection.connected = false;
        
        // Should not reconnect immediately (backoff period)
        assert!(!connection.should_reconnect());
    }
    
    #[test]
    fn test_pub_connection_reset_attempts() {
        let address = PubAddress::parse("net:hermies.club:8008~shs:YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=").unwrap();
        let mut connection = PubConnection::new(address);
        
        // Simulate failed attempts
        connection.attempts = 5;
        connection.last_error = Some("Connection failed".to_string());
        
        // Reset
        connection.reset_attempts();
        
        assert_eq!(connection.attempts, 0);
        assert!(connection.last_error.is_none());
    }
    
    #[tokio::test]
    async fn test_maintain_pub_connections_without_initialization() {
        let config = SSBConfig {
            enabled: true,
            feed_path: "~/.plurcast-ssb".to_string(),
            pubs: vec!["net:hermies.club:8008~shs:YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY=".to_string()],
        };
        
        let mut platform = SSBPlatform::new(&config);
        
        // Try to maintain connections without initializing
        let result = platform.maintain_pub_connections().await;
        
        // Should fail because keypair not loaded
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("keypair not loaded"));
    }
    
    // ============================================================================
    // Task 6.4: Posting integration tests
    // Requirements: 15.3, 15.5
    // ============================================================================
    
    #[tokio::test]
    async fn test_posting_to_new_feed() {
        use crate::credentials::{CredentialConfig, CredentialManager, StorageBackend};
        use tempfile::TempDir;
        
        // Create temporary directories
        let cred_dir = TempDir::new().unwrap();
        let feed_dir = TempDir::new().unwrap();
        
        // Setup credentials
        let cred_config = CredentialConfig {
            storage: StorageBackend::Encrypted,
            path: cred_dir.path().to_string_lossy().to_string(),
            master_password: Some("test-password-12345".to_string()),
        };
        let credentials = CredentialManager::new(cred_config).unwrap();
        
        // Generate and store keypair
        let keypair = SSBKeypair::generate();
        SSBPlatform::store_keypair(&credentials, &keypair, "test-account").unwrap();
        
        // Create platform with temporary feed path
        let config = SSBConfig {
            enabled: true,
            feed_path: feed_dir.path().to_string_lossy().to_string(),
            pubs: vec![],
        };
        
        let mut platform = SSBPlatform::new(&config);
        
        // Initialize platform
        platform.initialize_with_credentials(&credentials, "test-account").await.unwrap();
        
        // Post to new feed
        let content = "Hello SSB! This is my first post.";
        let result = platform.post(content).await;
        
        assert!(result.is_ok(), "Posting should succeed: {:?}", result.err());
        
        let message_id = result.unwrap();
        
        // Verify message ID format
        assert!(message_id.starts_with("ssb:%"), "Message ID should start with 'ssb:%'");
        
        // Verify feed database was created
        assert!(feed_dir.path().exists(), "Feed directory should exist");
        assert!(feed_dir.path().join("messages").exists(), "Messages directory should exist");
        assert!(feed_dir.path().join("feed.json").exists(), "Feed state file should exist");
        
        // Verify message file was created
        let message_file = feed_dir.path().join("messages").join("0000000001.json");
        assert!(message_file.exists(), "Message file should exist");
        
        // Read and verify message
        let message_json = std::fs::read_to_string(&message_file).unwrap();
        let message: SSBMessage = serde_json::from_str(&message_json).unwrap();
        
        assert_eq!(message.sequence, 1, "First message should have sequence 1");
        assert!(message.previous.is_none(), "First message should have no previous");
        assert_eq!(message.author, keypair.id, "Message author should match keypair");
        assert!(message.signature.is_some(), "Message should be signed");
        
        // Verify content
        let content_obj = message.content.as_object().unwrap();
        assert_eq!(content_obj.get("type").unwrap().as_str().unwrap(), "post");
        assert_eq!(content_obj.get("text").unwrap().as_str().unwrap(), content);
    }
    
    #[tokio::test]
    async fn test_posting_multiple_messages() {
        use crate::credentials::{CredentialConfig, CredentialManager, StorageBackend};
        use tempfile::TempDir;
        
        // Create temporary directories
        let cred_dir = TempDir::new().unwrap();
        let feed_dir = TempDir::new().unwrap();
        
        // Setup credentials
        let cred_config = CredentialConfig {
            storage: StorageBackend::Encrypted,
            path: cred_dir.path().to_string_lossy().to_string(),
            master_password: Some("test-password-12345".to_string()),
        };
        let credentials = CredentialManager::new(cred_config).unwrap();
        
        // Generate and store keypair
        let keypair = SSBKeypair::generate();
        SSBPlatform::store_keypair(&credentials, &keypair, "test-account").unwrap();
        
        // Create platform
        let config = SSBConfig {
            enabled: true,
            feed_path: feed_dir.path().to_string_lossy().to_string(),
            pubs: vec![],
        };
        
        let mut platform = SSBPlatform::new(&config);
        platform.initialize_with_credentials(&credentials, "test-account").await.unwrap();
        
        // Post multiple messages
        let messages = vec![
            "First post",
            "Second post",
            "Third post",
        ];
        
        let mut message_ids = Vec::new();
        
        for content in &messages {
            let result = platform.post(content).await;
            assert!(result.is_ok(), "Posting should succeed: {:?}", result.err());
            message_ids.push(result.unwrap());
        }
        
        // Verify all message IDs are unique
        let unique_ids: std::collections::HashSet<_> = message_ids.iter().collect();
        assert_eq!(unique_ids.len(), messages.len(), "All message IDs should be unique");
        
        // Verify all message files exist
        for i in 1..=messages.len() {
            let message_file = feed_dir.path().join("messages").join(format!("{:010}.json", i));
            assert!(message_file.exists(), "Message file {} should exist", i);
            
            // Read and verify message
            let message_json = std::fs::read_to_string(&message_file).unwrap();
            let message: SSBMessage = serde_json::from_str(&message_json).unwrap();
            
            assert_eq!(message.sequence, i as u64, "Message should have correct sequence");
            
            if i == 1 {
                assert!(message.previous.is_none(), "First message should have no previous");
            } else {
                assert!(message.previous.is_some(), "Subsequent messages should have previous");
            }
        }
        
        // Verify feed state
        let feed_state_file = feed_dir.path().join("feed.json");
        let state_json = std::fs::read_to_string(&feed_state_file).unwrap();
        let state: serde_json::Value = serde_json::from_str(&state_json).unwrap();
        
        assert_eq!(
            state.get("sequence").unwrap().as_u64().unwrap(),
            messages.len() as u64,
            "Feed state should reflect last sequence"
        );
    }
    
    #[tokio::test]
    async fn test_posting_error_not_initialized() {
        let config = SSBConfig {
            enabled: true,
            feed_path: "~/.plurcast-ssb-test".to_string(),
            pubs: vec![],
        };
        
        let platform = SSBPlatform::new(&config);
        
        // Try to post without initializing
        let result = platform.post("Hello SSB!").await;
        
        assert!(result.is_err(), "Posting should fail when not initialized");
        
        let err = result.unwrap_err();
        assert!(err.to_string().contains("not initialized"), "Error should mention not initialized");
    }
    
    #[tokio::test]
    async fn test_posting_error_content_too_large() {
        use crate::credentials::{CredentialConfig, CredentialManager, StorageBackend};
        use tempfile::TempDir;
        
        // Create temporary directories
        let cred_dir = TempDir::new().unwrap();
        let feed_dir = TempDir::new().unwrap();
        
        // Setup credentials
        let cred_config = CredentialConfig {
            storage: StorageBackend::Encrypted,
            path: cred_dir.path().to_string_lossy().to_string(),
            master_password: Some("test-password-12345".to_string()),
        };
        let credentials = CredentialManager::new(cred_config).unwrap();
        
        // Generate and store keypair
        let keypair = SSBKeypair::generate();
        SSBPlatform::store_keypair(&credentials, &keypair, "test-account").unwrap();
        
        // Create platform
        let config = SSBConfig {
            enabled: true,
            feed_path: feed_dir.path().to_string_lossy().to_string(),
            pubs: vec![],
        };
        
        let mut platform = SSBPlatform::new(&config);
        platform.initialize_with_credentials(&credentials, "test-account").await.unwrap();
        
        // Try to post content that's too large (> 8KB)
        let large_content = "x".repeat(8500);
        let result = platform.post(&large_content).await;
        
        assert!(result.is_err(), "Posting should fail for oversized content");
        
        let err = result.unwrap_err();
        let err_msg = err.to_string();
        assert!(err_msg.contains("exceeds SSB message size limit"), "Error should mention size limit");
        assert!(err_msg.contains("8KB"), "Error should mention 8KB limit");
    }
    
    #[tokio::test]
    async fn test_message_id_format() {
        use crate::credentials::{CredentialConfig, CredentialManager, StorageBackend};
        use tempfile::TempDir;
        
        // Create temporary directories
        let cred_dir = TempDir::new().unwrap();
        let feed_dir = TempDir::new().unwrap();
        
        // Setup credentials
        let cred_config = CredentialConfig {
            storage: StorageBackend::Encrypted,
            path: cred_dir.path().to_string_lossy().to_string(),
            master_password: Some("test-password-12345".to_string()),
        };
        let credentials = CredentialManager::new(cred_config).unwrap();
        
        // Generate and store keypair
        let keypair = SSBKeypair::generate();
        SSBPlatform::store_keypair(&credentials, &keypair, "test-account").unwrap();
        
        // Create platform
        let config = SSBConfig {
            enabled: true,
            feed_path: feed_dir.path().to_string_lossy().to_string(),
            pubs: vec![],
        };
        
        let mut platform = SSBPlatform::new(&config);
        platform.initialize_with_credentials(&credentials, "test-account").await.unwrap();
        
        // Post a message
        let result = platform.post("Test message").await;
        assert!(result.is_ok());
        
        let message_id = result.unwrap();
        
        // Verify message ID format: "ssb:%<base64-hash>"
        assert!(message_id.starts_with("ssb:%"), "Message ID should start with 'ssb:%'");
        assert!(message_id.len() > 10, "Message ID should have substantial length");
        
        // The hash part should be base64 (alphanumeric + / + =)
        let hash_part = &message_id[5..]; // Skip "ssb:%"
        assert!(
            hash_part.chars().all(|c| c.is_alphanumeric() || c == '/' || c == '+' || c == '='),
            "Hash part should be valid base64"
        );
    }
    
    #[tokio::test]
    async fn test_posting_preserves_message_chain() {
        use crate::credentials::{CredentialConfig, CredentialManager, StorageBackend};
        use tempfile::TempDir;
        
        // Create temporary directories
        let cred_dir = TempDir::new().unwrap();
        let feed_dir = TempDir::new().unwrap();
        
        // Setup credentials
        let cred_config = CredentialConfig {
            storage: StorageBackend::Encrypted,
            path: cred_dir.path().to_string_lossy().to_string(),
            master_password: Some("test-password-12345".to_string()),
        };
        let credentials = CredentialManager::new(cred_config).unwrap();
        
        // Generate and store keypair
        let keypair = SSBKeypair::generate();
        SSBPlatform::store_keypair(&credentials, &keypair, "test-account").unwrap();
        
        // Create platform
        let config = SSBConfig {
            enabled: true,
            feed_path: feed_dir.path().to_string_lossy().to_string(),
            pubs: vec![],
        };
        
        let mut platform = SSBPlatform::new(&config);
        platform.initialize_with_credentials(&credentials, "test-account").await.unwrap();
        
        // Post three messages
        platform.post("First").await.unwrap();
        platform.post("Second").await.unwrap();
        platform.post("Third").await.unwrap();
        
        // Read all messages and verify chain
        let msg1_json = std::fs::read_to_string(
            feed_dir.path().join("messages").join("0000000001.json")
        ).unwrap();
        let msg1: SSBMessage = serde_json::from_str(&msg1_json).unwrap();
        
        let msg2_json = std::fs::read_to_string(
            feed_dir.path().join("messages").join("0000000002.json")
        ).unwrap();
        let msg2: SSBMessage = serde_json::from_str(&msg2_json).unwrap();
        
        let msg3_json = std::fs::read_to_string(
            feed_dir.path().join("messages").join("0000000003.json")
        ).unwrap();
        let msg3: SSBMessage = serde_json::from_str(&msg3_json).unwrap();
        
        // Verify chain integrity
        assert!(msg1.previous.is_none(), "First message should have no previous");
        
        let hash1 = msg1.calculate_hash().unwrap();
        assert_eq!(msg2.previous, Some(hash1), "Second message should link to first");
        
        let hash2 = msg2.calculate_hash().unwrap();
        assert_eq!(msg3.previous, Some(hash2), "Third message should link to second");
        
        // Verify sequences
        assert_eq!(msg1.sequence, 1);
        assert_eq!(msg2.sequence, 2);
        assert_eq!(msg3.sequence, 3);
    }
    
    #[tokio::test]
    async fn test_posting_with_special_characters() {
        use crate::credentials::{CredentialConfig, CredentialManager, StorageBackend};
        use tempfile::TempDir;
        
        // Create temporary directories
        let cred_dir = TempDir::new().unwrap();
        let feed_dir = TempDir::new().unwrap();
        
        // Setup credentials
        let cred_config = CredentialConfig {
            storage: StorageBackend::Encrypted,
            path: cred_dir.path().to_string_lossy().to_string(),
            master_password: Some("test-password-12345".to_string()),
        };
        let credentials = CredentialManager::new(cred_config).unwrap();
        
        // Generate and store keypair
        let keypair = SSBKeypair::generate();
        SSBPlatform::store_keypair(&credentials, &keypair, "test-account").unwrap();
        
        // Create platform
        let config = SSBConfig {
            enabled: true,
            feed_path: feed_dir.path().to_string_lossy().to_string(),
            pubs: vec![],
        };
        
        let mut platform = SSBPlatform::new(&config);
        platform.initialize_with_credentials(&credentials, "test-account").await.unwrap();
        
        // Post content with special characters
        let content = "Hello 🌍! Testing special chars: @#$%^&*() \"quotes\" 'apostrophes' \n newlines \t tabs";
        let result = platform.post(content).await;
        
        assert!(result.is_ok(), "Posting with special characters should succeed");
        
        // Read and verify message
        let message_file = feed_dir.path().join("messages").join("0000000001.json");
        let message_json = std::fs::read_to_string(&message_file).unwrap();
        let message: SSBMessage = serde_json::from_str(&message_json).unwrap();
        
        // Verify content is preserved
        let content_obj = message.content.as_object().unwrap();
        assert_eq!(content_obj.get("text").unwrap().as_str().unwrap(), content);
    }
    
    #[tokio::test]
    async fn test_posting_empty_content() {
        use crate::credentials::{CredentialConfig, CredentialManager, StorageBackend};
        use tempfile::TempDir;
        
        // Create temporary directories
        let cred_dir = TempDir::new().unwrap();
        let feed_dir = TempDir::new().unwrap();
        
        // Setup credentials
        let cred_config = CredentialConfig {
            storage: StorageBackend::Encrypted,
            path: cred_dir.path().to_string_lossy().to_string(),
            master_password: Some("test-password-12345".to_string()),
        };
        let credentials = CredentialManager::new(cred_config).unwrap();
        
        // Generate and store keypair
        let keypair = SSBKeypair::generate();
        SSBPlatform::store_keypair(&credentials, &keypair, "test-account").unwrap();
        
        // Create platform
        let config = SSBConfig {
            enabled: true,
            feed_path: feed_dir.path().to_string_lossy().to_string(),
            pubs: vec![],
        };
        
        let mut platform = SSBPlatform::new(&config);
        platform.initialize_with_credentials(&credentials, "test-account").await.unwrap();
        
        // Post empty content (should succeed - SSB allows empty posts)
        let result = platform.post("").await;
        assert!(result.is_ok(), "Posting empty content should succeed");
    }
}

