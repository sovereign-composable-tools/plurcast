//! Integration tests for retry rate limiting features
//!
//! Tests the startup_delay, inter_retry_delay, and max_retries_per_iteration features
//! that prevent burst retries and rate limit violations.

use assert_cmd::Command;
use libplurcast::{Database, Post, PostStatus};
use predicates::prelude::*;
use std::fs;
use std::time::Instant;
use tempfile::TempDir;

/// Setup test environment with config and database
async fn setup_test_env() -> (TempDir, String, String) {
    let temp_dir = TempDir::new().unwrap();
    let config_path = temp_dir.path().join("config.toml");
    let db_path = temp_dir.path().join("test.db");

    // Create minimal config with scheduling settings
    let config_content = format!(
        r#"
[database]
path = "{}"

[scheduling]
poll_interval = 1
max_retries = 3
retry_delay = 1
startup_delay = 2
inter_retry_delay = 1
max_retries_per_iteration = 3

[scheduling.rate_limits.nostr]
posts_per_hour = 100
"#,
        db_path.display().to_string().replace('\\', "/")
    );

    fs::write(&config_path, config_content).unwrap();

    // Initialize database
    let _db = Database::new(db_path.to_str().unwrap()).await.unwrap();

    (
        temp_dir,
        config_path.to_str().unwrap().to_string(),
        db_path.to_str().unwrap().to_string(),
    )
}

/// Create a failed post for retry testing with post_records
async fn create_failed_post(db_path: &str, content: &str) -> String {
    use libplurcast::PostRecord;

    let db = Database::new(db_path).await.unwrap();
    let now = chrono::Utc::now().timestamp();

    let post = Post {
        id: uuid::Uuid::new_v4().to_string(),
        content: content.to_string(),
        created_at: now,
        scheduled_at: None,
        status: PostStatus::Failed,
        metadata: Some(r#"{"platforms":["nostr"]}"#.to_string()),
    };

    let post_id = post.id.clone();
    db.create_post(&post).await.unwrap();

    // Create a post_record showing a failed attempt
    // This is necessary for the retry logic to work
    let record = PostRecord {
        id: None, // Will be auto-generated by database
        post_id: post_id.clone(),
        platform: "nostr".to_string(),
        platform_post_id: None,
        posted_at: Some(now - 3600), // Failed 1 hour ago
        success: false,
        error_message: Some("test failure".to_string()),
        account_name: "default".to_string(),
    };

    db.create_post_record(&record).await.unwrap();
    post_id
}

// STARTUP DELAY TESTS

#[tokio::test]
async fn test_startup_delay_from_config() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    // Create a failed post
    create_failed_post(&db_path, "Failed post").await;

    let mut cmd = Command::cargo_bin("plur-send").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("--once")
        .assert()
        .success()
        .stderr(predicate::str::contains(
            "Waiting 2s before processing retries (startup delay)",
        ));
}

#[tokio::test]
async fn test_startup_delay_from_cli() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    // Create a failed post
    create_failed_post(&db_path, "Failed post").await;

    let mut cmd = Command::cargo_bin("plur-send").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("--once")
        .arg("--startup-delay")
        .arg("3")
        .assert()
        .success()
        .stderr(predicate::str::contains(
            "Waiting 3s before processing retries (startup delay)",
        ));
}

#[tokio::test]
async fn test_startup_delay_cli_overrides_config() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    // Create a failed post
    create_failed_post(&db_path, "Failed post").await;

    let mut cmd = Command::cargo_bin("plur-send").unwrap();

    // Config has startup_delay=2, CLI specifies 5
    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("--once")
        .arg("--startup-delay")
        .arg("5")
        .assert()
        .success()
        .stderr(predicate::str::contains(
            "Waiting 5s before processing retries (startup delay)",
        ));
}

#[tokio::test]
async fn test_startup_delay_timing() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    // Create a failed post
    create_failed_post(&db_path, "Failed post").await;

    let start = Instant::now();

    let mut cmd = Command::cargo_bin("plur-send").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("--once")
        .arg("--startup-delay")
        .arg("2")
        .assert()
        .success();

    let duration = start.elapsed();

    // Should take at least 2 seconds (with small tolerance)
    assert!(
        duration.as_secs() >= 2,
        "Startup delay should wait at least 2 seconds, got {:?}",
        duration
    );
}

#[tokio::test]
async fn test_no_startup_delay_by_default() {
    let temp_dir = TempDir::new().unwrap();
    let config_path = temp_dir.path().join("config.toml");
    let db_path = temp_dir.path().join("test.db");

    // Create config without startup_delay
    let config_content = format!(
        r#"
[database]
path = "{}"

[scheduling]
poll_interval = 1
max_retries = 3
retry_delay = 1
"#,
        db_path.display().to_string().replace('\\', "/")
    );

    fs::write(&config_path, config_content).unwrap();
    let _db = Database::new(db_path.to_str().unwrap()).await.unwrap();

    create_failed_post(db_path.to_str().unwrap(), "Failed post").await;

    let mut cmd = Command::cargo_bin("plur-send").unwrap();

    cmd.env("PLURCAST_CONFIG", config_path.to_str().unwrap())
        .arg("--once")
        .assert()
        .success()
        .stderr(
            predicate::str::contains("Waiting")
                .and(predicate::str::contains(
                    "before processing retries (startup delay)",
                ))
                .not(),
        );
}

// NO-RETRY FLAG TESTS

#[tokio::test]
async fn test_no_retry_flag_skips_retry_processing() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    // Create failed posts
    create_failed_post(&db_path, "Failed post 1").await;
    create_failed_post(&db_path, "Failed post 2").await;

    let mut cmd = Command::cargo_bin("plur-send").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("--once")
        .arg("--no-retry")
        .assert()
        .success()
        .stderr(predicate::str::contains(
            "Skipping retry processing (--no-retry flag set)",
        ));
}

#[tokio::test]
async fn test_no_retry_flag_skips_startup_delay() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    create_failed_post(&db_path, "Failed post").await;

    let start = Instant::now();

    let mut cmd = Command::cargo_bin("plur-send").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("--once")
        .arg("--no-retry")
        .assert()
        .success();

    let duration = start.elapsed();

    // Should NOT wait for startup delay
    assert!(
        duration.as_secs() < 2,
        "With --no-retry, should not wait for startup delay, got {:?}",
        duration
    );
}

#[tokio::test]
async fn test_no_retry_still_processes_scheduled_posts() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;
    let db = Database::new(&db_path).await.unwrap();
    let now = chrono::Utc::now().timestamp();

    // Create a scheduled post that's due
    let post = Post {
        id: uuid::Uuid::new_v4().to_string(),
        content: "Scheduled post".to_string(),
        created_at: now,
        scheduled_at: Some(now - 10), // 10 seconds in the past
        status: PostStatus::Scheduled,
        metadata: Some(r#"{"platforms":["nostr"]}"#.to_string()),
    };
    db.create_post(&post).await.unwrap();

    // Also create a failed post
    create_failed_post(&db_path, "Failed post").await;

    let mut cmd = Command::cargo_bin("plur-send").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("--once")
        .arg("--no-retry")
        .assert()
        .success()
        .stderr(predicate::str::contains("Found 1 post(s) due for posting"))
        .stderr(predicate::str::contains("Skipping retry processing"));
}

// INTER-RETRY DELAY TESTS

#[tokio::test]
async fn test_inter_retry_delay_from_config() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    // Create 2 failed posts
    create_failed_post(&db_path, "Failed post 1").await;
    create_failed_post(&db_path, "Failed post 2").await;

    let mut cmd = Command::cargo_bin("plur-send").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("--once")
        .assert()
        .success()
        .stderr(predicate::str::contains(
            "Waiting 1s before next retry (inter-retry delay)",
        ));
}

#[tokio::test]
async fn test_inter_retry_delay_default() {
    let temp_dir = TempDir::new().unwrap();
    let config_path = temp_dir.path().join("config.toml");
    let db_path = temp_dir.path().join("test.db");

    // Create config without inter_retry_delay specified
    let config_content = format!(
        r#"
[database]
path = "{}"

[scheduling]
poll_interval = 1
"#,
        db_path.display().to_string().replace('\\', "/")
    );

    fs::write(&config_path, config_content).unwrap();
    let _db = Database::new(db_path.to_str().unwrap()).await.unwrap();

    // Create 2 failed posts
    create_failed_post(db_path.to_str().unwrap(), "Failed post 1").await;
    create_failed_post(db_path.to_str().unwrap(), "Failed post 2").await;

    let mut cmd = Command::cargo_bin("plur-send").unwrap();

    cmd.env("PLURCAST_CONFIG", config_path.to_str().unwrap())
        .arg("--once")
        .assert()
        .success()
        // Default should be 5 seconds
        .stderr(predicate::str::contains(
            "Waiting 5s before next retry (inter-retry delay)",
        ));
}

// MAX RETRIES PER ITERATION TESTS

#[tokio::test]
async fn test_max_retries_per_iteration_limits_processing() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    // Create 5 failed posts, but config has max_retries_per_iteration=3
    for i in 1..=5 {
        create_failed_post(&db_path, &format!("Failed post {}", i)).await;
    }

    let mut cmd = Command::cargo_bin("plur-send").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("--once")
        .assert()
        .success()
        .stderr(predicate::str::contains("Found 5 failed post(s) to retry"))
        .stderr(predicate::str::contains(
            "Reached max retries per iteration (3), will process remaining posts in next poll",
        ));
}

#[tokio::test]
async fn test_max_retries_per_iteration_default() {
    let temp_dir = TempDir::new().unwrap();
    let config_path = temp_dir.path().join("config.toml");
    let db_path = temp_dir.path().join("test.db");

    // Create config without max_retries_per_iteration specified
    let config_content = format!(
        r#"
[database]
path = "{}"

[scheduling]
poll_interval = 1
"#,
        db_path.display().to_string().replace('\\', "/")
    );

    fs::write(&config_path, config_content).unwrap();
    let _db = Database::new(db_path.to_str().unwrap()).await.unwrap();

    // Create 15 failed posts (more than default of 10)
    for i in 1..=15 {
        create_failed_post(db_path.to_str().unwrap(), &format!("Failed post {}", i)).await;
    }

    let mut cmd = Command::cargo_bin("plur-send").unwrap();

    cmd.env("PLURCAST_CONFIG", config_path.to_str().unwrap())
        .arg("--once")
        .assert()
        .success()
        .stderr(predicate::str::contains("Found 15 failed post(s) to retry"))
        // Default should be 10
        .stderr(predicate::str::contains(
            "Reached max retries per iteration (10), will process remaining posts in next poll",
        ));
}

#[tokio::test]
async fn test_max_retries_allows_all_if_under_limit() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    // Create only 2 failed posts (under the limit of 3)
    create_failed_post(&db_path, "Failed post 1").await;
    create_failed_post(&db_path, "Failed post 2").await;

    let mut cmd = Command::cargo_bin("plur-send").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("--once")
        .assert()
        .success()
        .stderr(predicate::str::contains("Found 2 failed post(s) to retry"))
        // Should NOT see the "Reached max retries" message
        .stderr(predicate::str::contains("Reached max retries per iteration").not());
}

// COMBINED FEATURES TESTS

#[tokio::test]
async fn test_startup_and_inter_retry_delays_combined() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    // Create 2 failed posts
    create_failed_post(&db_path, "Failed post 1").await;
    create_failed_post(&db_path, "Failed post 2").await;

    let start = Instant::now();

    let mut cmd = Command::cargo_bin("plur-send").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("--once")
        .assert()
        .success()
        .stderr(predicate::str::contains(
            "Waiting 2s before processing retries (startup delay)",
        ))
        .stderr(predicate::str::contains("Waiting 1s before next retry"));

    let duration = start.elapsed();

    // Should take at least: startup_delay (2s) + inter_retry_delay (1s) = 3s
    assert!(
        duration.as_secs() >= 3,
        "Should wait for both startup and inter-retry delays, got {:?}",
        duration
    );
}

#[tokio::test]
async fn test_all_rate_limiting_features_together() {
    let (_temp_dir, config_path, db_path) = setup_test_env().await;

    // Create 5 failed posts
    for i in 1..=5 {
        create_failed_post(&db_path, &format!("Failed post {}", i)).await;
    }

    let mut cmd = Command::cargo_bin("plur-send").unwrap();

    cmd.env("PLURCAST_CONFIG", &config_path)
        .arg("--once")
        .assert()
        .success()
        // Should see startup delay
        .stderr(predicate::str::contains(
            "Waiting 2s before processing retries (startup delay)",
        ))
        // Should see max retries limit
        .stderr(predicate::str::contains("Found 5 failed post(s) to retry"))
        .stderr(predicate::str::contains(
            "Reached max retries per iteration (3)",
        ))
        // Should see inter-retry delay
        .stderr(predicate::str::contains("Waiting 1s before next retry"));
}

// CONFIGURATION VALIDATION TESTS

#[tokio::test]
async fn test_zero_startup_delay_is_valid() {
    let temp_dir = TempDir::new().unwrap();
    let config_path = temp_dir.path().join("config.toml");
    let db_path = temp_dir.path().join("test.db");

    let config_content = format!(
        r#"
[database]
path = "{}"

[scheduling]
poll_interval = 1
startup_delay = 0
"#,
        db_path.display().to_string().replace('\\', "/")
    );

    fs::write(&config_path, config_content).unwrap();
    let _db = Database::new(db_path.to_str().unwrap()).await.unwrap();

    create_failed_post(db_path.to_str().unwrap(), "Failed post").await;

    let mut cmd = Command::cargo_bin("plur-send").unwrap();

    cmd.env("PLURCAST_CONFIG", config_path.to_str().unwrap())
        .arg("--once")
        .assert()
        .success()
        // Should not apply any delay
        .stderr(predicate::str::contains("Applying startup delay").not());
}

#[tokio::test]
async fn test_zero_inter_retry_delay_is_valid() {
    let temp_dir = TempDir::new().unwrap();
    let config_path = temp_dir.path().join("config.toml");
    let db_path = temp_dir.path().join("test.db");

    let config_content = format!(
        r#"
[database]
path = "{}"

[scheduling]
poll_interval = 1
inter_retry_delay = 0
"#,
        db_path.display().to_string().replace('\\', "/")
    );

    fs::write(&config_path, config_content).unwrap();
    let _db = Database::new(db_path.to_str().unwrap()).await.unwrap();

    // Create 2 failed posts
    create_failed_post(db_path.to_str().unwrap(), "Failed post 1").await;
    create_failed_post(db_path.to_str().unwrap(), "Failed post 2").await;

    let mut cmd = Command::cargo_bin("plur-send").unwrap();

    cmd.env("PLURCAST_CONFIG", config_path.to_str().unwrap())
        .arg("--once")
        .assert()
        .success()
        // Should not apply any inter-retry delay
        .stderr(
            predicate::str::contains("Waiting")
                .and(predicate::str::contains("before next retry"))
                .not(),
        );
}
